<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boardbreaker - Strategic Board Game v2.1</title>
    
    <!-- Cache Busting & Version Info -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="version" content="2.1-characters-integrated">
    <meta name="last-updated" content="2024-12-19">
    
    <!-- Google Fonts - Space Grotesk Geometric Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* ===== BOARDBREAKER GAME STYLES ===== */
        
        :root {
            --primary-color: #2563eb;
            --secondary-color: #7c3aed;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --dark-color: #1f2937;
            --light-color: #f8fafc;
            --border-color: #e2e8f0;
            --board-bg: #ffffff;
            --square-size: 80px;
            --gap-size: 2px;
            
            /* Character Theme Variables - Dynamic */
            --character-primary: #2563eb;
            --character-secondary: #7c3aed;
            --character-accent: #10b981;
            --character-bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --character-text: #1f2937;
            --character-light: #f8fafc;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 700;
            background: var(--character-bg);
            color: var(--character-text);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
            transition: all 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        /* ===== GAME CONTAINER ===== */
        
        .game-container {
            min-height: 100vh;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            background: #ffffff;
        }

        .game-header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .game-title {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.8px;
        }

        .game-stats {
            display: flex;
            gap: 2rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            letter-spacing: -0.3px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* ===== MAIN GAME AREA ===== */
        
        .game-main {
            flex: 1;
            display: flex;
            padding: 1rem;
            gap: 1rem;
            align-items: flex-start;
            overflow-y: auto;
            min-height: 0;
        }

        .game-board-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
            background: url('Assets/gameboard.png') center/cover no-repeat;
            position: relative;
        }
        
        .game-board-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            z-index: 1;
        }

        .game-board {
            background: rgba(255, 255, 255, 0.6);
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 2;
            backdrop-filter: blur(3px);
        }

        .board-grid {
            display: grid;
            grid-template-columns: repeat(10, var(--square-size));
            grid-template-rows: repeat(5, var(--square-size));
            gap: var(--gap-size);
            position: relative;
        }

        .board-square {
            width: var(--square-size);
            height: var(--square-size);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1rem;
            cursor: default;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.9);
            color: rgba(55, 65, 81, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 1);
        }

        .board-square::after {
            content: attr(data-number);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            backdrop-filter: blur(4px) saturate(1.2);
            background: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 2px 6px;
            font-weight: 700;
            color: #374151;
            z-index: 1;
        }
        
        .board-square.disabled {
            cursor: not-allowed;
            opacity: 0.6;
            pointer-events: none;
        }

        .board-square:hover {
            animation: jitter 0.3s ease-in-out;
        }
        
        @keyframes jitter {
            0% { transform: scale(1); }
            25% { transform: scale(1.06); }
            50% { transform: scale(1.03); }
            75% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Square Types */
        .square-safe { 
            background: #ffffff;
            color: #059669; 
            border: 3px solid #10b981;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.2);
        }
        
        .square-animation { 
            background: #ffffff;
            color: var(--character-primary); 
            border: 3px solid var(--character-accent);
            box-shadow: 0 2px 8px rgba(var(--character-primary), 0.2);
        }
        
        .square-movement { 
            background: #ffffff;
            color: #2563eb; 
            border: 3px solid #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }
        

        
        .square-battle { 
            background: #ffffff;
            color: #dc2626; 
            border: 3px solid #ef4444;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.2);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .square-random { 
            background: #ffffff;
            color: #0891b2; 
            border: 3px solid #06b6d4;
            box-shadow: 0 2px 8px rgba(6, 182, 212, 0.2);
        }
        .square-persona { background: #ffffff; color: #ea580c; border: 3px solid #f97316; box-shadow: 0 2px 8px rgba(249, 115, 22, 0.2); }
        .square-start { 
            background: #ffffff; 
            color: #16a34a; 
            border: 3px solid #22c55e; 
            font-weight: 900; 
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.2);
            position: relative;
        }
        .square-finish { 
            background: #ffffff; 
            color: #dc2626; 
            border: 3px solid #ef4444; 
            font-weight: 900; 
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.2);
            position: relative;
        }

        /* Make START and FINISH squares clickable */
        .square-start, .square-finish {
            cursor: pointer;
        }
        
        .square-start:hover, .square-finish:hover {
            transform: scale(1.03);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        /* Playing card flip animation */
        .playing-card {
            transition: transform 0.6s ease-in-out;
        }
        
        .playing-card:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .card-back, .card-front {
            transition: transform 0.6s ease-in-out;
        }

        /* Ladders and Chutes */
        .ladder {
            position: absolute;
            background: linear-gradient(90deg, #fbbf24, #f59e0b, #fbbf24);
            border-radius: 4px;
            z-index: 15;
            opacity: 0.9;
            box-shadow: 0 2px 8px rgba(251, 191, 36, 0.4);
            border: 2px solid #d97706;
        }
        
        /* Simple Green Ladder - Vertical */
        .ladder-vertical {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            /* Add green horizontal rungs for vertical ladders */
            background-image: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 18px,
                #16a34a 18px,
                #16a34a 24px,
                transparent 24px,
                transparent 42px
            );
        }
        
        .ladder-vertical::before {
            content: '';
            position: absolute;
            top: 0;
            left: 2px;
            width: 4px;
            height: 100%;
            background: #16a34a;
            border-radius: 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 1;
        }
        
        .ladder-vertical::after {
            content: '';
            position: absolute;
            top: 0;
            right: 2px;
            width: 4px;
            height: 100%;
            background: #16a34a;
            border-radius: 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 1;
        }
        
        /* Simple Green Ladder - Diagonal */
        .ladder-diagonal {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            /* Add green diagonal rungs for diagonal ladders */
            background-image: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 20px,
                #16a34a 20px,
                #16a34a 26px,
                transparent 26px,
                transparent 46px
            );
        }
        
        .ladder-diagonal::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 0;
            width: 100%;
            height: 4px;
            background: #16a34a;
            border-radius: 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 1;
        }
        
        .ladder-diagonal::after {
            content: '';
            position: absolute;
            bottom: 2px;
            left: 0;
            width: 100%;
            height: 4px;
            background: #16a34a;
            border-radius: 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 1;
        }

        .chute {
            position: absolute;
            background: transparent;
            z-index: 15;
            opacity: 0.9;
        }
        
        /* Curved Slide - Vertical */
        .chute-vertical {
            background: linear-gradient(0deg, 
                #ff6b6b 0%, 
                #ffa8a8 25%, 
                #ff6b6b 50%, 
                #ffa8a8 75%, 
                #ff6b6b 100%);
            border-radius: 25px;
            border: 4px solid #e03131;
            box-shadow: 
                0 4px 15px rgba(224, 49, 49, 0.4),
                inset -2px 0 4px rgba(255, 255, 255, 0.3),
                inset 2px 0 4px rgba(0, 0, 0, 0.1);
        }
        
        .chute-vertical::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 15%;
            width: 70%;
            height: 80%;
            background: linear-gradient(0deg, 
                rgba(255, 255, 255, 0.4) 0%, 
                rgba(255, 255, 255, 0.2) 50%, 
                rgba(255, 255, 255, 0.4) 100%);
            border-radius: 15px;
            z-index: 1;
        }
        
        .chute-vertical::after {
            content: '';
            position: absolute;
            top: 15%;
            left: 20%;
            width: 60%;
            height: 70%;
            background: radial-gradient(ellipse at center, 
                rgba(255, 255, 255, 0.3) 0%, 
                transparent 70%);
            border-radius: 50%;
            z-index: 2;
        }
        
        /* Curved Slide - Diagonal */
        .chute-diagonal {
            background: linear-gradient(90deg, 
                #ff6b6b 0%, 
                #ffa8a8 25%, 
                #ff6b6b 50%, 
                #ffa8a8 75%, 
                #ff6b6b 100%);
            border-radius: 15px;
            border: 4px solid #e03131;
            box-shadow: 
                0 4px 15px rgba(224, 49, 49, 0.4),
                inset 0 -2px 4px rgba(255, 255, 255, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .chute-diagonal::before {
            content: '';
            position: absolute;
            top: 15%;
            left: 10%;
            width: 80%;
            height: 70%;
            background: linear-gradient(90deg, 
                rgba(255, 255, 255, 0.4) 0%, 
                rgba(255, 255, 255, 0.2) 50%, 
                rgba(255, 255, 255, 0.4) 100%);
            border-radius: 8px;
            z-index: 1;
        }
        
        .chute-diagonal::after {
            content: '';
            position: absolute;
            top: 25%;
            left: 15%;
            width: 70%;
            height: 50%;
            background: radial-gradient(ellipse at center, 
                rgba(255, 255, 255, 0.3) 0%, 
                transparent 70%);
            border-radius: 50%;
            z-index: 2;
        }

        /* Player Piece */
        .player-piece {
            position: absolute;
            width: calc(var(--square-size) - 10px);
            height: calc(var(--square-size) - 10px);
            border-radius: 50%;
            background: radial-gradient(circle, #ffffff, #e5e7eb);
            border: 3px solid var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 900;
            z-index: 20;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            backdrop-filter: blur(6px);
        }
        
        .player-piece::before {
            content: '';
            position: absolute;
            width: 110%;
            height: 110%;
            left: -5%;
            top: -5%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px);
            z-index: -1;
        }

        .player-piece.moving {
            transform: scale(1.2);
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.5);
        }
        
        .player-piece.special-movement {
            z-index: 25;
            transform: scale(1.3);
            filter: drop-shadow(0 0 15px rgba(59, 130, 246, 1)) drop-shadow(0 0 8px rgba(255, 255, 255, 0.8));
            transition: none; /* Disable CSS transitions for smooth JS animation */
        }
        
        /* Temporary message animation */
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* ===== SCOREBOARD STYLES ===== */
        .score-row.gold { background: linear-gradient(90deg, rgba(255, 215, 0, 0.1), transparent); }
        .score-row.silver { background: linear-gradient(90deg, rgba(192, 192, 192, 0.1), transparent); }
        .score-row.bronze { background: linear-gradient(90deg, rgba(205, 127, 50, 0.1), transparent); }
        
        .score-row:hover {
            background: rgba(59, 130, 246, 0.1) !important;
            transform: translateY(-1px);
            transition: all 0.2s ease;
        }
        
        .scoreboard-table::-webkit-scrollbar {
            width: 8px;
        }
        
        .scoreboard-table::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }
        
        .scoreboard-table::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        /* ===== LOADING SCREEN ===== */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .loading-screen.active {
            opacity: 1;
        }

        .loading-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('Assets/gameboard.png') center/cover no-repeat;
            background-attachment: fixed;
        }

        .loading-background::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
        }

        .loading-background::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.2),
                rgba(255, 255, 255, 0.4),
                rgba(255, 255, 255, 0.2),
                transparent
            );
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .loading-content {
            position: relative;
            text-align: center;
            color: white;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 3rem 2rem;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .loading-title {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.5px;
        }

        .loading-subtitle {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.2rem;
            font-weight: 500;
            color: #e5e7eb;
            margin-bottom: 2rem;
            letter-spacing: 0.3px;
        }

        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }

        .spinner-ring {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(34, 197, 94, 0.3);
            border-top-color: #22c55e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .spinner-ring:nth-child(2) {
            animation-delay: 0.2s;
        }

        .spinner-ring:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ===== GAME SIDEBAR ===== */
        
        .game-sidebar {
            width: 320px;
            min-width: 320px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            height: fit-content;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
        }

        .sidebar-section {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .sidebar-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }

        /* Dice Section */
        .dice-container {
            text-align: center;
        }

        .dice {
            width: 80px;
            height: 80px;
            background: white;
            border: 3px solid var(--primary-color);
            border-radius: 12px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 900;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
        }

        .dice:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.3);
        }

        .dice.rolling {
            animation: diceRoll 1s ease-in-out;
        }

        @keyframes diceRoll {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(1.2); }
            75% { transform: rotate(270deg) scale(1.1); }
        }

        .roll-button {
            background: var(--character-primary);
            color: var(--character-light);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .roll-button:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .roll-button:hover:before {
            left: 100%;
        }

        .roll-button:hover {
            background: var(--character-secondary);
            transform: translateY(-1px);
            box-shadow: 0 6px 20px var(--character-primary);
        }

        .roll-button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .roll-button:disabled:before {
            display: none;
        }

        /* Persona Display */
        .persona-display {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .persona-trait {
            background: var(--light-color);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
        }

        .trait-name {
            font-weight: 600;
        }

        .trait-value {
            color: var(--primary-color);
            font-weight: 500;
        }

        /* Debuffs Display */
        .debuffs-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .debuff-item {
            background: #fef2f2;
            border: 1px solid #fecaca;
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .debuff-name {
            font-weight: 600;
            color: var(--danger-color);
            margin-bottom: 0.25rem;
        }

        .debuff-description {
            color: #7f1d1d;
            font-size: 0.8rem;
        }

        /* ===== BUTTONS ===== */
        
        .btn {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            background: var(--secondary-color);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .btn-secondary {
            background: #6b7280;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-warning {
            background: var(--warning-color);
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-danger {
            background: var(--danger-color);
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        /* ===== MODALS ===== */
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
        }

        .modal.active .modal-content {
            transform: scale(1) translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: var(--danger-color);
        }

        /* ===== SETUP SCREENS ===== */
        
        .setup-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: url('Assets/introscreen2.png') center/cover no-repeat;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
            overflow-y: auto;
            padding: 1rem 0;
            transition: all 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        .setup-card {
            border-radius: 20px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            margin: auto;
            max-height: 70vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.95);
        }

        .setup-title {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.8px;
        }

        .setup-subtitle {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.1rem;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 2rem;
            letter-spacing: 0.25px;
        }

        .persona-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .persona-option {
            background: var(--light-color);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0 auto 1rem auto;
            max-width: 100%;
            display: block;
        }

        .persona-option:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
        }

        .persona-option.selected {
            border-color: var(--primary-color);
            background: #dbeafe;
        }

        .persona-name {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }

        .persona-description {
            font-size: 0.9rem;
            color: #6b7280;
        }

        /* ===== CHARACTER BUILDER STYLES ===== */
        
        .character-builder {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .character-preview {
            background: var(--light-color);
            border: 3px solid var(--border-color);
            border-radius: 16px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 300px;
        }
        
        .character-avatar {
            width: 260px;
            height: 260px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        


        /* ===== GAMEPLAY PREVIEW MODAL ===== */
        
        .gameplay-preview {
            max-width: 600px;
            width: 90%;
        }
        
        .preview-section {
            background: var(--light-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
        }
        
        .preview-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.75rem;
        }
        
        .preview-description {
            color: #6b7280;
            line-height: 1.6;
            margin-bottom: 0.5rem;
        }
        
        .preview-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .preview-stat {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
        }
        
        .preview-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .preview-stat-label {
            font-size: 0.9rem;
            color: #6b7280;
        }

        /* ===== RESPONSIVE DESIGN ===== */
        
        @media (max-width: 1024px) {
            .customization-content {
                grid-template-columns: 1fr !important;
                gap: 1rem !important;
                min-height: auto !important;
            }
            
            .character-builder {
                min-width: auto !important;
                margin-top: 1rem;
                height: auto !important;
            }
            
            .setup-card {
                padding: 1.5rem;
                max-width: 90% !important;
            }
            
            .character-preview {
                height: 200px;
                margin-bottom: 1rem !important;
            }
            
            .persona-selector {
                max-height: 300px !important;
            }
        }

        @media (max-width: 768px) {
            .game-main {
                flex-direction: column;
                padding: 0.5rem;
                gap: 0.5rem;
            }
            
            .game-sidebar {
                width: 100%;
                min-width: auto;
                max-height: 50vh;
                order: 2;
            }
            
            .game-board-container {
                order: 1;
                min-height: 50vh;
            }
            
            .game-header {
                padding: 0.5rem 1rem;
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .game-stats {
                gap: 0.5rem;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .game-title {
                font-size: 1.5rem;
            }
            
            :root {
                --square-size: 60px;
                --gap-size: 2px;
            }
            
            .setup-card {
                padding: 1rem;
                margin: 0.5rem;
                max-width: 400px;
                width: 95%;
                max-height: calc(100vh - 1rem);
            }
            
            .setup-title {
                font-size: 1.8rem;
            }
            
            .setup-subtitle {
                font-size: 1rem;
            }
            
            .persona-option {
                padding: 1rem;
                margin-bottom: 0.5rem;
            }
            
            .character-avatar {
                width: 220px;
                height: 220px;
                font-size: 1rem;
            }
            

        }

        @media (max-width: 480px) {
            :root {
                --square-size: 50px;
            }
            
            .setup-title {
                font-size: 1.5rem;
            }
            
            .character-avatar {
                width: 200px;
                height: 200px;
                font-size: 1rem;
            }
            
            .character-preview {
                height: 240px;
            }
            

            
            .game-sidebar {
                max-height: 40vh;
            }
        }

        /* ===== ANIMATIONS ===== */
        
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .bounce {
            animation: bounce 0.6s ease-in-out;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @keyframes stormMovement {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes diceGlow {
            0% { 
                filter: drop-shadow(0 0 20px #fbbf24);
                transform: scale(1);
            }
            100% { 
                filter: drop-shadow(0 0 40px #f59e0b);
                transform: scale(1.1);
            }
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div id="welcomeScreen" class="setup-screen">
        <div class="setup-card">
            <div class="setup-title">Boardbreaker</div>
            <div class="setup-subtitle">Strategic Board Game - Navigate to Square 49 and Survive!</div>
            
            <div style="margin: 3rem 0;">
                <div style="font-size: 4rem; margin-bottom: 1rem; font-weight: bold; color: var(--primary-color);">BOARD</div>
                <div style="font-size: 1.2rem; color: #6b7280; margin-bottom: 2rem;">
                    Choose your persona, customize your character, and face the ultimate board challenge
                </div>
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
            <button id="enterGameBtn" class="btn" style="font-size: 1.3rem; padding: 18px 40px; background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));">
                Play
            </button>
                <button class="btn btn-secondary" onclick="showScoreboard()" style="font-size: 1.1rem; padding: 12px 30px;">
                    üèÜ Leaderboard
            </button>
            </div>
        </div>
    </div>

    <!-- Character Customization Screen -->
    <div id="customizationScreen" class="setup-screen" style="display: none;">
        <div class="setup-card" style="max-width: 900px; width: 95%; margin: auto; padding: 2rem;">
            <div class="setup-title">üé® Character Creation</div>
            <div class="setup-subtitle">Enter your name and design your character</div>
            
            <!-- Player Name Input -->
            <div style="margin: 1.5rem 0; text-align: center;">
                <label for="playerNameInput" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--primary-color);">Player Name:</label>
                <input type="text" id="playerNameInput" placeholder="Enter your name..." 
                       style="padding: 0.75rem; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 1rem; text-align: center; min-width: 250px; font-family: 'Space Grotesk', sans-serif;">
            </div>
            
            <!-- Main Content Area -->
            <div class="customization-content" style="display: grid; grid-template-columns: 1fr 320px; gap: 2rem; min-height: 500px; width: 100%; margin: 0 auto;">
                <!-- Left: Persona Selection -->
                <div class="persona-selector" style="overflow-y: auto; max-height: 500px; padding: 0 1rem; display: flex; flex-direction: column; align-items: center;">
                    <div class="persona-step" style="width: 100%; max-width: 400px; margin-bottom: 2rem; text-align: center;">
                        <h3 style="margin-bottom: 1rem; color: var(--primary-color);">Personality</h3>
                        <div class="persona-option" data-trait="personality" data-value="tactician">
                            <div class="persona-name">Tactician</div>
                            <div class="persona-description">+20% ladders, +15% chute length</div>
                        </div>
                        <div class="persona-option" data-trait="personality" data-value="daredevil">
                            <div class="persona-name">Daredevil</div>
                            <div class="persona-description">+15% shortcuts, +20% traps</div>
                        </div>
                    </div>
                    
                    <div class="persona-step" style="width: 100%; max-width: 400px; margin-bottom: 2rem; text-align: center;">
                        <h3 style="margin-bottom: 1rem; color: var(--primary-color);">Playstyle</h3>
                        <div class="persona-option" data-trait="playstyle" data-value="lucky">
                            <div class="persona-name">Lucky</div>
                            <div class="persona-description">+15% bonus squares, +10% easy mini-games</div>
                        </div>
                        <div class="persona-option" data-trait="playstyle" data-value="persistent">
                            <div class="persona-name">Persistent</div>
                            <div class="persona-description">+15% small obstacles, -10% chute frequency</div>
                        </div>
                    </div>
                    
                    <div class="persona-step" style="width: 100%; max-width: 400px; margin-bottom: 2rem; text-align: center;">
                        <h3 style="margin-bottom: 1rem; color: var(--primary-color);">Movement</h3>
                        <div class="persona-option" data-trait="movement" data-value="sprinter">
                            <div class="persona-name">Sprinter</div>
                            <div class="persona-description">+1 square movement average, +15% stop tiles</div>
                        </div>
                        <div class="persona-option" data-trait="movement" data-value="jumper">
                            <div class="persona-name">Jumper</div>
                            <div class="persona-description">Can skip 1 square after landing, +15% sticky tiles</div>
                        </div>
                    </div>
                </div>
                
                <!-- Right: Character Builder -->
                <div class="character-builder" style="display: flex; flex-direction: column; justify-content: space-between; height: 500px;">
                    <div style="flex-shrink: 0;">
                    <h3 style="margin-bottom: 1rem; color: var(--primary-color); text-align: center;">Your Character</h3>
                    
                        <div class="character-preview" style="margin-bottom: 2rem;">
                            <div id="characterDisplay" class="character-avatar" style="background: #f3f4f6;">
                            <div style="color: #9ca3af; font-size: 1rem; text-align: center;">Select traits to see your character</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: auto;">
                        <!-- Main Play Button -->
                        <button id="playGameBtn" class="btn" style="width: 100%; font-size: 1.2rem; padding: 1rem; background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); color: white; border: none; border-radius: 12px; cursor: pointer; transition: all 0.3s ease; position: relative; z-index: 999;" disabled onclick="console.log('Direct onclick handler triggered!')">
                            Select All Traits First
                    </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Game Interface -->
    <div id="gameInterface" class="game-container" style="display: none;">
        <div class="game-header">
            <div class="game-title">Boardbreaker</div>
            <div class="game-stats">
                <div class="stat-item">
                    <div id="currentTurn" class="stat-value">1</div>
                    <div class="stat-label">Turn</div>
                </div>
                <div class="stat-item">
                    <div id="currentPosition" class="stat-value">1</div>
                    <div class="stat-label">Position</div>
                </div>
                <div class="stat-item">
                    <div id="gameTime" class="stat-value">00:00</div>
                    <div class="stat-label">Time</div>
                </div>
                <div class="stat-item">
                    <div id="strengthScore" class="stat-value">100</div>
                    <div class="stat-label">Strength</div>
                </div>
            </div>
        </div>

        <div class="game-main">
            <div class="game-board-container">
                <div class="game-board">
                    <div id="gameBoard" class="board-grid">
                        <!-- Board squares will be generated here -->
                    </div>
                    <div id="playerPiece" class="player-piece"></div>
                </div>
            </div>

            <div class="game-sidebar">
                <div class="sidebar-section">
                    <div class="sidebar-title">Dice Roll</div>
                    <div class="dice-container">
                        <div id="dice" class="dice">?</div>
                        <button id="rollDiceBtn" class="roll-button">Roll Dice</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-title">Your Persona</div>
                    <div id="personaDisplay" class="persona-display">
                        <!-- Persona traits will be displayed here -->
                    </div>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-title">Active Effects</div>
                    <div id="debuffsList" class="debuffs-list">
                        <div style="text-align: center; color: #6b7280; font-size: 0.9rem;">No active effects</div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <div class="sidebar-title">Game Actions</div>
                    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                        <button class="btn btn-secondary" onclick="showGameRules()">üìñ Rules</button>
                        <button class="btn btn-warning" onclick="resetGame()">üîÑ New Game</button>
                        <button class="btn btn-danger" onclick="quitGame()">‚ùå Quit</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="squareModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="modalTitle">Square Effect</div>
            </div>
            <div id="modalContent">
                <!-- Square content will be loaded here -->
            </div>
            <div id="defaultModalFooter" style="text-align: center; margin-top: 1.5rem;">
                <button class="btn" onclick="closeModal('squareModal')">Continue</button>
            </div>
        </div>
    </div>

    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="gameOverTitle">Game Over</div>
                <button class="modal-close" onclick="closeModal('gameOverModal')">&times;</button>
            </div>
            <div id="gameOverContent">
                <!-- Game over content will be loaded here -->
            </div>
            <div style="text-align: center; margin-top: 1.5rem;">
                <button class="btn btn-success" onclick="resetGame()">üîÑ Play Again</button>
                <button class="btn btn-secondary" onclick="quitGame()">‚ùå Quit</button>
            </div>
        </div>
    </div>

    <!-- Gameplay Preview Modal -->
    <div id="gameplayPreviewModal" class="modal">
        <div class="modal-content gameplay-preview">
            <div class="modal-header">
                <div class="modal-title">Your Gameplay Preview</div>
                <button class="modal-close" onclick="closeModal('gameplayPreviewModal')">&times;</button>
            </div>
            
            <div id="gameplayPreviewContent">
                <!-- Dynamic content will be generated here -->
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
                <button class="btn btn-secondary" onclick="editCharacter()">Edit</button>
                <button class="btn btn-success" onclick="continueToGame()">Continue</button>
            </div>
        </div>
    </div>

    <!-- Scoreboard Modal -->
    <div id="scoreboardModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <div class="modal-title">üèÜ Boardbreaker Leaderboard</div>
                <button class="modal-close" onclick="closeModal('scoreboardModal')">&times;</button>
            </div>
            
            <div id="scoreboardContent">
                <!-- Scoreboard will be generated here -->
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
                <button class="btn btn-secondary" onclick="clearScoreboard()">üóëÔ∏è Clear History</button>
                <button class="btn btn-primary" onclick="closeModal('scoreboardModal')">Close</button>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen" style="display: none;">
        <div class="loading-background"></div>
        <div class="loading-content">
            <div class="loading-title">Preparing Your Adventure</div>
            <div class="loading-subtitle">Generating your personalized board...</div>
            <div class="loading-spinner">
                <div class="spinner-ring"></div>
                <div class="spinner-ring"></div>
                <div class="spinner-ring"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== BOARDBREAKER GAME ENGINE =====
        
        class BoardbreakerGame {
            constructor() {
                this.gameState = {
                    isPlaying: false,
                    currentPlayer: null,
                    board: null,
                    currentPosition: 0,
                    turn: 1,
                    startTime: null,
                    gameTime: 0,
                    strengthScore: 100,
                    deathCounters: {},
                    activeDebuffs: [],
                    lastRoll: null,
                    canRoll: true,
                    gameHistory: [],
                    playerName: 'Anonymous' // Default player name
                };
                
                this.personas = {
                    personality: null,
                    playstyle: null,
                    movement: null
                };
                
                this.character = {
                    color: '#2563eb',
                    image: null,
                    name: 'Default',
                    theme: 'default'
                };
                
                this.playerName = '';
                
                // Character themes based on persona combinations (mapped to PRD character images)
                this.characterThemes = {
                    // PRD 8.2 ‚Üí character2.png
                    'tactician-lucky-jumper': {
                        name: 'Tactician + Lucky + Jumper',
                        image: 'Assets/character2.png',
                        colors: {
                            primary: '#22c55e',
                            secondary: '#84cc16',
                            accent: '#10b981',
                            bg: 'linear-gradient(135deg, #22c55e 0%, #84cc16 100%)',
                            text: '#14532d',
                            light: '#f0fdf4'
                        }
                    },
                    // PRD 8.3 ‚Üí character3.png
                    'tactician-persistent-sprinter': {
                        name: 'Tactician + Persistent + Sprinter',
                        image: 'Assets/character3.png',
                        colors: {
                            primary: '#7c3aed',
                            secondary: '#a855f7',
                            accent: '#8b5cf6',
                            bg: 'linear-gradient(135deg, #7c3aed 0%, #a855f7 100%)',
                            text: '#581c87',
                            light: '#faf5ff'
                        }
                    },
                    // PRD 8.6 ‚Üí character6.png
                    'daredevil-lucky-jumper': {
                        name: 'Daredevil + Lucky + Jumper',
                        image: 'Assets/character6.png',
                        colors: {
                            primary: '#9333ea',
                            secondary: '#c084fc',
                            accent: '#a855f7',
                            bg: 'linear-gradient(135deg, #9333ea 0%, #c084fc 100%)',
                            text: '#581c87',
                            light: '#faf5ff'
                        }
                    },
                    // PRD 8.1 ‚Üí character1.png
                    'tactician-lucky-sprinter': {
                        name: 'Tactician + Lucky + Sprinter',
                        image: 'Assets/character1.png',
                        colors: {
                            primary: '#0891b2',
                            secondary: '#06b6d4',
                            accent: '#22d3ee',
                            bg: 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)',
                            text: '#164e63',
                            light: '#f0fdff'
                        }
                    },
                    // PRD 8.8 ‚Üí character8.png
                    'daredevil-persistent-jumper': {
                        name: 'Daredevil + Persistent + Jumper',
                        image: 'Assets/character8.png',
                        colors: {
                            primary: '#eab308',
                            secondary: '#f59e0b',
                            accent: '#fbbf24',
                            bg: 'linear-gradient(135deg, #eab308 0%, #f59e0b 100%)',
                            text: '#713f12',
                            light: '#fefce8'
                        }
                    },
                    // PRD 8.4 ‚Üí character4.png
                    'tactician-persistent-jumper': {
                        name: 'Tactician + Persistent + Jumper',
                        image: 'Assets/character4.png',
                        colors: {
                            primary: '#f97316',
                            secondary: '#ea580c',
                            accent: '#fb923c',
                            bg: 'linear-gradient(135deg, #f97316 0%, #ea580c 100%)',
                            text: '#9a3412',
                            light: '#fff7ed'
                        }
                    },
                    // PRD 8.5 ‚Üí character5.png
                    'daredevil-lucky-sprinter': {
                        name: 'Daredevil + Lucky + Sprinter',
                        image: 'Assets/character5.png',
                        colors: {
                            primary: '#16a34a',
                            secondary: '#22c55e',
                            accent: '#4ade80',
                            bg: 'linear-gradient(135deg, #16a34a 0%, #22c55e 100%)',
                            text: '#14532d',
                            light: '#f0fdf4'
                        }
                    },
                    // PRD 8.7 ‚Üí character7.png
                    'daredevil-persistent-sprinter': {
                        name: 'Daredevil + Persistent + Sprinter',
                        image: 'Assets/character7.png',
                        colors: {
                            primary: '#0d9488',
                            secondary: '#14b8a6',
                            accent: '#5eead4',
                            bg: 'linear-gradient(135deg, #0d9488 0%, #14b8a6 100%)',
                            text: '#134e4a',
                            light: '#f0fdfa'
                        }
                    }
                };
                
                this.boardGenerator = new BoardGenerator();
                this.squareSystem = new SquareSystem();
                this.animationEngine = new AnimationEngine();
                this.scoreSystem = new ScoreSystem();
                this.pendingModalCallback = null;
                
                this.init();
            }
            
            init() {
                console.log('Initializing Boardbreaker Game Engine');
                this.setupEventListeners();
                this.loadSavedData();
            }
            
            setupEventListeners() {
                // Welcome screen
                document.getElementById('enterGameBtn').addEventListener('click', () => this.enterGame());
                
                // Persona selection
                document.querySelectorAll('.persona-option').forEach(option => {
                    option.addEventListener('click', (e) => this.selectPersonaTrait(e));
                });
                
                // Play game button (customization screen) with debugging
                const playGameButton = document.getElementById('playGameBtn');
                if (playGameButton) {
                    // Remove any existing event listeners first
                    playGameButton.replaceWith(playGameButton.cloneNode(true));
                    const freshPlayButton = document.getElementById('playGameBtn');
                    
                    freshPlayButton.addEventListener('click', (e) => {
                        console.log('üéØ Play button clicked!');
                        console.log('Button disabled state:', e.target.disabled);
                        console.log('Button pointer events:', window.getComputedStyle(e.target).pointerEvents);
                        console.log('Current personas:', this.personas);
                        
                        // Force enable button interaction
                        e.target.style.pointerEvents = 'auto';
                        
                        // Check if all personas are selected and name is entered
                        const allSelected = Object.values(this.personas).every(p => p !== null);
                        const nameInput = document.getElementById('playerNameInput');
                        const hasName = nameInput && nameInput.value.trim().length > 0;
                        
                        console.log('‚úÖ Validation check:', { allSelected, hasName });
                        
                        if (!allSelected || !hasName) {
                            console.log('‚ùå Not ready to play - missing requirements');
                            alert('Please select all character traits and enter your name first!');
                            return false;
                        }
                        
                        console.log('‚úÖ Starting game preview...');
                        this.showGameplayPreview();
                    });
                    
                    console.log('‚úÖ Play button event listener added');
                } else {
                    console.error('‚ùå Play button not found!');
                }
                
                // Dice roll button
                document.getElementById('rollDiceBtn').addEventListener('click', () => this.rollDice());
                
                // Board squares are no longer clickable - mystery until you land on them!
                // EXCEPT for START and FINISH squares which show helpful info
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('square-start')) {
                        this.showSquareEffect('üé≤ Ready to Start?', `
                            <div style="text-align: center; padding: 1rem;">
                                <div style="font-size: 1.2rem; margin-bottom: 1rem;">üöÄ Begin Your Adventure!</div>
                                <div style="margin-bottom: 1rem;">Roll the dice to start your journey through the board.</div>
                                <div style="color: #16a34a; font-weight: 600;">Click "Roll Dice" when you're ready!</div>
                            </div>
                        `);
                    } else if (e.target.classList.contains('square-finish')) {
                        this.showSquareEffect('üèÜ Victory Awaits!', `
                            <div style="text-align: center; padding: 1rem;">
                                <div style="font-size: 1.2rem; margin-bottom: 1rem; color: #dc2626;">üéØ How to Win & Lose</div>
                                
                                <div style="margin-bottom: 1rem;">
                                    <strong style="color: #16a34a;">üèÜ Victory Condition:</strong><br>
                                    Reach square 50 to WIN the game!
                                </div>
                                
                                <div style="margin-bottom: 1rem;">
                                    <strong style="color: #dc2626;">üíÄ Defeat Conditions:</strong><br>
                                    Each character has unique death conditions based on their chosen traits.<br>
                                    Avoid triggering your character's specific weaknesses!
                                </div>
                                
                                <div style="color: #7c3aed; font-weight: 600; font-size: 1.1rem;">
                                    üí™ You've got this! Strategy and luck will guide you to victory!
                                </div>
                            </div>
                        `);
                    }
                });
                

            }
            
            enterGame() {
                document.getElementById('welcomeScreen').style.display = 'none';
                document.getElementById('customizationScreen').style.display = 'block';
                
                // Reset selections
                this.personas = { personality: null, playstyle: null, movement: null };
                document.querySelectorAll('.persona-option').forEach(opt => opt.classList.remove('selected'));
                
                // Reset player name
                this.playerName = '';
                const nameInput = document.getElementById('playerNameInput');
                if (nameInput) {
                    nameInput.value = '';
                    nameInput.addEventListener('input', () => this.validatePlayButton());
                }
                
                // Reset character preview
                this.updateCharacterPreview();
                
                const playBtn = document.getElementById('playGameBtn');
                if (playBtn) {
                    playBtn.disabled = true;
                    playBtn.textContent = 'Select All Traits First';
                    playBtn.style.background = 'linear-gradient(135deg, #6b7280, #4b5563)';
                    playBtn.style.cursor = 'not-allowed';
                    playBtn.style.opacity = '0.7';
                    playBtn.style.pointerEvents = 'auto'; // Always allow pointer events for debugging
                    console.log('üîÑ Reset play button to disabled state');
                }
            }
            

            
            adjustBrightness(hex, percent) {
                const num = parseInt(hex.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                    (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }
            
            selectPersonaTrait(event) {
                const option = event.target.closest('.persona-option');
                const trait = option.dataset.trait;
                const value = option.dataset.value;
                
                // Remove selection from other options in same category
                document.querySelectorAll(`[data-trait="${trait}"]`).forEach(opt => {
                    opt.classList.remove('selected');
                });
                
                // Select this option
                option.classList.add('selected');
                this.personas[trait] = value;
                
                // Update character preview immediately (even with partial selection)
                this.updateCharacterPreview();
                
                // Update character theme if all traits selected
                const allSelected = Object.values(this.personas).every(p => p !== null);
                if (allSelected) {
                    this.updateCharacterTheme();
                }
                
                const playBtn = document.getElementById('playGameBtn');
                if (playBtn) {
                    playBtn.disabled = !allSelected;
                    if (allSelected) {
                        playBtn.textContent = `üéÆ Play as ${this.getPersonaDescription()}!`;
                        playBtn.style.backgroundColor = '#10b981';
                        playBtn.style.cursor = 'pointer';
                        playBtn.style.opacity = '1';
                        console.log('‚úÖ All personas selected, Play button enabled');
                        console.log('Button state - disabled:', playBtn.disabled, 'text:', playBtn.textContent);
                    } else {
                        playBtn.textContent = 'Select All Traits First';
                        playBtn.style.backgroundColor = '#6b7280';
                        playBtn.style.cursor = 'not-allowed';
                        playBtn.style.opacity = '0.6';
                        console.log('‚ö†Ô∏è Not all personas selected, Play button disabled');
                        console.log('Button state - disabled:', playBtn.disabled, 'text:', playBtn.textContent);
                    }
                }
            }
            
            updateCharacterPreview() {
                const characterDisplay = document.getElementById('characterDisplay');
                
                // Check if we have all three traits selected
                const allSelected = Object.values(this.personas).every(p => p !== null);
                
                if (allSelected) {
                    // Generate the key for character themes
                    const key = `${this.personas.personality}-${this.personas.playstyle}-${this.personas.movement}`;
                    const theme = this.characterThemes[key];
                    
                    if (theme && theme.image) {
                        // Show the character image using background-image (simple and reliable)
                        characterDisplay.innerHTML = '';
                        characterDisplay.style.backgroundImage = `url('${theme.image}')`;
                        characterDisplay.style.backgroundSize = 'cover';
                        characterDisplay.style.backgroundPosition = 'center';
                        characterDisplay.style.backgroundRepeat = 'no-repeat';
                        characterDisplay.style.backgroundColor = 'transparent';
                        characterDisplay.style.border = 'none';
                        console.log(`Character preview updated: ${theme.name} - ${theme.image}`);
                    }
                } else {
                    // Show placeholder text
                    characterDisplay.innerHTML = '<div style="color: #9ca3af; font-size: 1rem; text-align: center;">Select traits to see your character</div>';
                    characterDisplay.style.backgroundImage = 'none';
                    characterDisplay.style.backgroundColor = '#f3f4f6';
                    characterDisplay.style.border = 'none';
                }
            }
            
            updateCharacterTheme() {
                const key = `${this.personas.personality}-${this.personas.playstyle}-${this.personas.movement}`;
                const theme = this.characterThemes[key];
                
                if (theme) {
                    this.character = { ...this.character, ...theme };
                    
                    // Update CSS variables for dynamic theming
                    const root = document.documentElement;
                    root.style.setProperty('--character-primary', theme.colors.primary);
                    root.style.setProperty('--character-secondary', theme.colors.secondary);
                    root.style.setProperty('--character-accent', theme.colors.accent);
                    root.style.setProperty('--character-bg', theme.colors.bg);
                    root.style.setProperty('--character-text', theme.colors.text);
                    root.style.setProperty('--character-light', theme.colors.light);
                    
                    // Update character display: use persona image per PRD mapping
                    const characterDisplay = document.getElementById('characterDisplay');
                    if (characterDisplay) {
                        characterDisplay.textContent = '';
                        characterDisplay.style.backgroundImage = theme.image ? `url('${theme.image}')` : 'none';
                        characterDisplay.style.backgroundColor = 'transparent';
                        characterDisplay.style.borderColor = theme.colors.accent;
                    }
                    
                    console.log(`üé® Character theme updated to: ${theme.name}`);
                }
            }
            
            getPersonaDescription() {
                const names = {
                    tactician: 'Tactician',
                    daredevil: 'Daredevil', 
                    lucky: 'Lucky',
                    persistent: 'Persistent',
                    sprinter: 'Sprinter',
                    jumper: 'Jumper'
                };
                
                return `${names[this.personas.personality]} ${names[this.personas.playstyle]} ${names[this.personas.movement]}`;
            }
            
            validatePlayButton() {
                const allSelected = Object.values(this.personas).every(p => p !== null);
                const nameInput = document.getElementById('playerNameInput');
                const playerName = nameInput ? nameInput.value.trim() : '';
                const hasName = playerName.length > 0;
                
                this.playerName = playerName;
                
                const playBtn = document.getElementById('playGameBtn');
                if (playBtn) {
                    const canPlay = allSelected && hasName;
                    playBtn.disabled = !canPlay;
                    
                    if (canPlay) {
                        playBtn.textContent = `üéÆ Play as ${playerName}!`;
                        playBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                        playBtn.style.cursor = 'pointer';
                        playBtn.style.opacity = '1';
                        playBtn.style.transform = 'none';
                        playBtn.style.pointerEvents = 'auto';
                        playBtn.disabled = false; // Explicitly enable
                        console.log('‚úÖ Ready to play:', playerName, this.getPersonaDescription());
                    } else if (!hasName) {
                        playBtn.textContent = 'Enter Your Name';
                        playBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                        playBtn.style.cursor = 'pointer'; // Changed to pointer for testing
                        playBtn.style.opacity = '0.8';
                        playBtn.style.pointerEvents = 'auto'; // Always allow clicks for debugging
                        playBtn.disabled = true;
                    } else {
                        playBtn.textContent = 'Select All Traits First';
                        playBtn.style.background = 'linear-gradient(135deg, #6b7280, #4b5563)';
                        playBtn.style.cursor = 'pointer'; // Changed to pointer for testing
                        playBtn.style.opacity = '0.7';
                        playBtn.style.pointerEvents = 'auto'; // Always allow clicks for debugging
                        playBtn.disabled = true;
                    }
                }
            }
            
            showGameplayPreview() {
                console.log('üéÆ showGameplayPreview() called');
                console.log('Current personas:', this.personas);
                console.log('Player name:', this.playerName);
                
                // Double-check all personas are selected and name is entered
                const allSelected = Object.values(this.personas).every(p => p !== null);
                const hasName = this.playerName.trim().length > 0;
                console.log('All personas selected?', allSelected);
                console.log('Has name?', hasName);
                
                if (!allSelected || !hasName) {
                    alert('Please select all traits and enter your name before playing!');
                    return;
                }
                
                try {
                const content = this.generateGameplayPreview();
                document.getElementById('gameplayPreviewContent').innerHTML = content;
                showModal('gameplayPreviewModal');
                    console.log('‚úÖ Gameplay preview modal shown');
                } catch (error) {
                    console.error('‚ùå Error showing gameplay preview:', error);
                    alert('Error showing preview: ' + error.message);
                }
            }
            
            generateGameplayPreview() {
                const traits = {
                    personality: { tactician: 'Tactician', daredevil: 'Daredevil' },
                    playstyle: { lucky: 'Lucky', persistent: 'Persistent' },
                    movement: { sprinter: 'Sprinter', jumper: 'Jumper' }
                };
                
                const descriptions = {
                    tactician: 'Strategic player who gets more ladders (+20%) and longer chutes for planning.',
                    daredevil: 'Risk-taker who faces more shortcuts (+15%) but also more traps (+20%).',
                    lucky: 'Fortune favored with more bonus squares (+15%) and easier mini-games.',
                    persistent: 'Determined fighter with more obstacles (+15%) but fewer chutes to fall down.',
                    sprinter: 'Fast mover with +1 average movement but more stop tiles to control speed.',
                    jumper: 'Agile character who can skip squares but faces more sticky tiles.'
                };
                
                const deathConditions = {
                    tactician: 'Avoid being trapped 3 times',
                    daredevil: 'Don\'t hit 3 traps in a row',
                    lucky: 'Can\'t lose 3 luck-based mini-games',
                    persistent: 'Maximum 5 total mini-game failures',
                    sprinter: 'Reach the finish as fast as possible',
                    jumper: 'Can\'t fail 3 jumps consecutively'
                };
                
                return `
                    <div class="preview-section">
                        <div class="preview-title">Your Character: ${this.getPersonaDescription()}</div>
                        <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                            <div class="character-avatar" style="width: 80px; height: 80px; background-color: transparent; border: 4px solid ${this.character.color}; padding: 0;">
                                ${this.character.image ? `<img src="${this.character.image}" alt="Character" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">` : ''}
                            </div>
                            <div>
                                <div><strong>Personality:</strong> ${descriptions[this.personas.personality]}</div>
                                <div><strong>Playstyle:</strong> ${descriptions[this.personas.playstyle]}</div>
                                <div><strong>Movement:</strong> ${descriptions[this.personas.movement]}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="preview-section">
                        <div class="preview-title">Your Death Conditions</div>
                        <div class="preview-description">
                            <div><strong>Personality Risk:</strong> ${deathConditions[this.personas.personality]}</div>
                            <div><strong>Playstyle Risk:</strong> ${deathConditions[this.personas.playstyle]}</div>
                            <div><strong>Movement Risk:</strong> ${deathConditions[this.personas.movement]}</div>
                        </div>
                    </div>
                    
                    <div class="preview-section">
                        <div class="preview-title">Your Mission</div>
                        <div class="preview-description">
                            Navigate the 10√ó5 wider snaking board from square 1 to square 50. Your persona combination will generate a unique board with different challenges, bonuses, and traps. Use strategy and luck to reach the finish while avoiding your specific death conditions!
                        </div>
                    </div>
                    
                    <div class="preview-stats">
                        <div class="preview-stat">
                            <div class="preview-stat-value">49</div>
                            <div class="preview-stat-label">Squares to Navigate</div>
                        </div>
                        <div class="preview-stat">
                            <div class="preview-stat-value">15+</div>
                            <div class="preview-stat-label">Different Square Types</div>
                        </div>
                    </div>
                `;
            }
            
            startGame() {
                console.log('üéÆ startGame() called!');
                console.log('Starting game with persona:', this.personas);
                console.log('Personas valid?', Object.values(this.personas).every(p => p !== null));
                
                // Check if personas are properly set
                if (!Object.values(this.personas).every(p => p !== null)) {
                    console.error('‚ùå Personas not properly set:', this.personas);
                    alert('Error: Character not fully customized. Please select all traits.');
                    return;
                }
                
                // Initialize game state
                this.gameState.isPlaying = true;
                this.gameState.currentPosition = 1; // Start on the first square (START)
                this.gameState.turn = 1;
                this.gameState.startTime = Date.now();
                this.gameState.strengthScore = 100;
                this.gameState.deathCounters = this.initializeDeathCounters();
                this.gameState.activeDebuffs = [];
                this.gameState.canRoll = true;
                this.gameState.playerName = this.playerName; // Set player name from character customizer
                this.gameState.rollCount = 0; // Track dice rolls for phantom preview (every 5th roll)
                
                // Generate board based on persona
                try {
                    console.log('üèóÔ∏è Generating board...');
                this.gameState.board = this.boardGenerator.generateBoard(this.personas);
                    console.log('‚úÖ Board generated successfully');
                } catch (error) {
                    console.error('‚ùå Board generation failed:', error);
                    alert('Error generating game board: ' + error.message);
                    
                    // Reset game state on failure
                    this.gameState.isPlaying = false;
                    this.gameState.canRoll = false;
                    
                    // Ensure dice button is disabled on failure
                    const diceBtn = document.getElementById('rollDiceBtn');
                    if (diceBtn) {
                        diceBtn.disabled = true;
                        console.log('üé≤ Dice button disabled due to board generation failure');
                    }
                    
                    // Fall back to showing customization screen
                    document.getElementById('gameInterface').style.display = 'none';
                    document.getElementById('customizationScreen').style.display = 'block';
                    return;
                }
                
                // Hide customization screen and show game
                document.getElementById('customizationScreen').style.display = 'none';
                document.getElementById('gameInterface').style.display = 'block';
                
                // Setup game interface
                this.renderBoard();
                this.updatePersonaDisplay();
                this.updateGameStats();
                this.positionPlayer();
                
                // Start game timer
                this.startGameTimer();
                
                // CRITICAL: Ensure dice button is enabled after successful game initialization
                setTimeout(() => {
                    const diceBtn = document.getElementById('rollDiceBtn');
                    if (diceBtn) {
                        diceBtn.disabled = false;
                        console.log('üé≤ Dice button explicitly enabled after game start');
                    }
                    // Check dice state for debugging
                    this.checkDiceButtonState();
                }, 100); // Small delay to ensure all UI elements are properly initialized
                
                console.log('‚úÖ Game started successfully');
                
                // Make game instance globally accessible for modal callbacks
                window.game = this;
            }
            
            initializeDeathCounters() {
                const counters = {};
                
                // Initialize death counters based on persona
                if (this.personas.personality === 'tactician') {
                    counters.trapped = 0; // Death at 3
                }
                if (this.personas.personality === 'daredevil') {
                    counters.consecutiveTraps = 0; // Death at 3
                }
                if (this.personas.playstyle === 'lucky') {
                    counters.luckFailures = 0; // Death at 3
                }
                if (this.personas.playstyle === 'persistent') {
                    counters.totalFailures = 0; // Death at 5
                }

                if (this.personas.movement === 'jumper') {
                    counters.failedJumps = 0; // Death at 3
                }
                
                return counters;
            }
            
            // Debug function to check dice button state
            checkDiceButtonState() {
                const diceBtn = document.getElementById('rollDiceBtn');
                const canRollState = this.gameState.canRoll;
                const isPlayingState = this.gameState.isPlaying;
                const buttonDisabled = diceBtn ? diceBtn.disabled : 'not found';
                
                console.log(`üé≤ DICE STATE CHECK: canRoll=${canRollState}, isPlaying=${isPlayingState}, buttonDisabled=${buttonDisabled}`);
                
                // Auto-fix if states are misaligned
                if (canRollState && isPlayingState && diceBtn && diceBtn.disabled) {
                    console.warn('üîß Auto-fixing misaligned dice button state');
                    diceBtn.disabled = false;
                }
            }

            rollDice() {
                if (!this.gameState.canRoll || !this.gameState.isPlaying) {
                    console.log('üé≤ Roll blocked - canRoll:', this.gameState.canRoll, 'isPlaying:', this.gameState.isPlaying);
                    this.checkDiceButtonState();
                    return;
                }
                
                this.gameState.canRoll = false;
                document.getElementById('rollDiceBtn').disabled = true;
                
                // Increment roll count and check for phantom preview
                this.gameState.rollCount++;
                const shouldShowPhantomPreview = (this.gameState.rollCount % 5 === 0);
                console.log(`üé≤ Roll ${this.gameState.rollCount}, phantom preview: ${shouldShowPhantomPreview}`);
                
                // Show phantom preview if it's every 5th roll
                if (shouldShowPhantomPreview) {
                    console.log('üëª Showing phantom preview before dice roll');
                    this.showPhantomPreview(() => {
                        // Continue with normal dice roll after preview
                        this.continueWithDiceRoll();
                    });
                } else {
                    // Normal dice roll
                    this.continueWithDiceRoll();
                }
            }
            
            continueWithDiceRoll() {
                // Animate dice roll
                const dice = document.getElementById('dice');
                dice.classList.add('rolling');
                
                // Simulate rolling animation
                let rollCount = 0;
                const rollInterval = setInterval(() => {
                    dice.textContent = Math.floor(Math.random() * 6) + 1;
                    rollCount++;
                    
                    if (rollCount >= 10) {
                        clearInterval(rollInterval);
                        
                        // Final roll result
                        let finalRoll = Math.floor(Math.random() * 6) + 1;
                        
                        // Apply persona modifiers
                        if (this.personas.movement === 'sprinter') {
                            // Sprinter gets +1 average (more likely to roll high)
                            if (Math.random() < 0.3) finalRoll = Math.min(6, finalRoll + 1);
                        }
                        
                        // Apply debuff modifiers
                        const slowRollDebuff = this.gameState.activeDebuffs.find(d => d.type === 'slowRoll');
                        if (slowRollDebuff) {
                            finalRoll = Math.min(3, finalRoll); // Cap at 1-3
                        }
                        
                        // Check for doubleRoll effect
                        const doubleRollEffect = this.gameState.activeDebuffs.find(d => d.type === 'doubleRoll');
                        if (doubleRollEffect) {
                            const originalRoll = finalRoll;
                            finalRoll = originalRoll * 2;
                            
                            // Show doubling animation
                            dice.textContent = originalRoll;
                            setTimeout(() => {
                                dice.textContent = `${originalRoll} ‚Üí ${finalRoll}`;
                                setTimeout(() => {
                        dice.textContent = finalRoll;
                                    console.log(`üéØ Double Trouble activated! ${originalRoll} √ó 2 = ${finalRoll}`);
                                }, 800);
                            }, 500);
                        } else {
                            dice.textContent = finalRoll;
                        }
                        
                        dice.classList.remove('rolling');
                        
                        this.gameState.lastRoll = finalRoll;
                        
                        // Show dice result in console
                        console.log(`üé≤ Player rolled ${finalRoll}, moving ${finalRoll} spaces from position ${this.gameState.currentPosition}`);
                        
                        // Move player after delay
                        setTimeout(() => {
                            this.movePlayer(finalRoll);
                        }, 500);
                    }
                }, 100);
            }
            
            movePlayer(steps) {
                const startPosition = this.gameState.currentPosition;
                
                // Check for bonus movement effect
                const bonusMoveEffect = this.gameState.activeDebuffs.find(effect => effect.type === 'bonusMove');
                let totalSteps = steps;
                if (bonusMoveEffect) {
                    totalSteps += 1; // Add one extra space
                    console.log(`üé≤ Bonus movement activated! Moving ${totalSteps} spaces instead of ${steps}`);
                    
                    // Consume the bonus movement effect
                    bonusMoveEffect.turnsRemaining = 0; // Will be cleaned up in processDebuffs
                }
                
                let newPosition = startPosition + totalSteps;
                
                // Handle finish line - just land on square 50
                if (newPosition > 50) {
                    newPosition = 50; // Land on finish
                }
                
                // Animate normal player movement (zigzag board pattern)
                this.animationEngine.animatePlayerMovement(startPosition, newPosition, () => {
                    this.gameState.currentPosition = newPosition;
                    this.positionPlayer();
                    
                    // Check win condition
                    if (newPosition >= 50) {
                        this.gameWon();
                        return;
                    }
                    
                    // Resolve square effects
                    this.resolveSquare(newPosition);
                }, false, 'üé≤'); // Normal movement
            }
            
            resolveSquare(position) {
                const square = this.gameState.board.squares[position - 1];
                console.log(`Resolving square ${position}:`, square);
                
                // Check for active prevention first
                const hasPrevention = this.hasActivePrevention(position);
                if (hasPrevention) {
                    console.log(`üõ°Ô∏è Prevention active for position ${position} - neutralizing bad effects`);
                    
                    // Handle chutes with prevention
                    if (square.chute) {
                        this.showSquareEffect('üõ°Ô∏è Protection Activated!', `Foresight prevented you from sliding down the chute! You stay on square ${position}.`, () => {
                            this.consumePrevention(position);
                            this.endTurn();
                        });
                        return;
                    }
                    
                    // Check if this square type would be bad
                    if (this.isBadTile({square, position})) {
                        this.showSquareEffect('üõ°Ô∏è Protection Activated!', `Foresight neutralized the harmful effects of this tile! You rest safely on square ${position}.`, () => {
                            this.consumePrevention(position);
                            this.endTurn();
                        });
                        return;
                    }
                }
                
                // Handle ladders and chutes first
                if (square.ladder) {
                    const ladderEnd = square.ladder.end;
                    console.log(`ü™ú Player hit ladder at ${position}, transporting to ${ladderEnd}`);
                    
                    // Show popup first, then animate after user clicks OK
                    this.showSquareEffect('Ladder! ü™ú', `Dice roll moved you to square ${position}. Now climbing ladder to square ${ladderEnd}!`, () => {
                        console.log(`üé¨ Starting ladder animation from ${position} to ${ladderEnd}`);
                        this.animationEngine.animatePlayerMovement(position, ladderEnd, () => {
                            this.gameState.currentPosition = ladderEnd;
                            this.positionPlayer();
                            console.log(`‚úÖ Player successfully moved to ladder end: ${ladderEnd}`);
                            this.endTurn();
                        }, true, 'ü™ú'); // Special movement for ladders
                        });
                    return;
                }
                
                // Handle chutes (only if no prevention)
                if (square.chute && !hasPrevention) {
                    const chuteEnd = square.chute.end;
                    console.log(`üõù Player hit chute at ${position}, transporting to ${chuteEnd}`);
                    
                    // Show popup first, then animate after user clicks OK
                    this.showSquareEffect('Chute! üõù', `Dice roll moved you to square ${position}. Now sliding down chute to square ${chuteEnd}!`, () => {
                        console.log(`üé¨ Starting chute animation from ${position} to ${chuteEnd}`);
                        this.animationEngine.animatePlayerMovement(position, chuteEnd, () => {
                            this.gameState.currentPosition = chuteEnd;
                            this.positionPlayer();
                            console.log(`‚úÖ Player successfully moved to chute end: ${chuteEnd}`);
                            this.endTurn();
                        }, true, 'üõù'); // Special movement for chutes
                        });
                    return;
                }
                
                // Handle square type effects
                this.squareSystem.resolveSquare(square, this.gameState, this.personas, this)
                    .then((result) => {
                        // Check if prevention already handled this
                        if (result.preventionHandled) {
                            return; // Prevention logic already ended the turn
                        }
                        
                        if (result.gameOver) {
                            this.gameOver(result.message);
                        } else if (result.showEffect) {
                            // Check if this is a movement effect
                            if (result.movementAction) {
                                // Check prevention for movement effects
                                if (hasPrevention && this.isBadMovement(result)) {
                                    this.showSquareEffect('üõ°Ô∏è Protection Activated!', `Foresight prevented the harmful movement effect! You stay on square ${position}.`, () => {
                                        this.consumePrevention(position);
                                        this.endTurn();
                                    });
                                    return;
                                }
                                
                                // Show popup first, then animate movement after user clicks OK
                                console.log(`üéØ Movement action triggered:`, result.movementAction);
                                this.showSquareEffect(result.title, result.message, () => {
                                    const action = result.movementAction;
                                    console.log(`üé¨ CALLBACK EXECUTED: Starting ${action.type} animation from ${action.from} to ${action.to}`);
                                    console.log(`üìç Current position before movement: ${this.gameState.currentPosition}`);
                                    
                                    this.animationEngine.animatePlayerMovement(action.from, action.to, () => {
                                        this.gameState.currentPosition = action.to;
                                        this.positionPlayer();
                                        console.log(`‚úÖ Player successfully moved to: ${action.to}`);
                                        console.log(`üìç Current position after movement: ${this.gameState.currentPosition}`);
                                        this.endTurn();
                                    }, true, action.type === 'moveBack' ? '‚¨ÖÔ∏è' : '‚û°Ô∏è');
                                });
                            } else {
                                // Check prevention for debuffs
                                if (hasPrevention && result.debuff) {
                                    this.showSquareEffect('üõ°Ô∏è Protection Activated!', `Foresight prevented the harmful effect! You rest safely on square ${position}.`, () => {
                                        this.consumePrevention(position);
                                        this.endTurn();
                                    });
                                    return;
                                }
                                
                                // Regular square effect (no movement)
                                // Check for custom animations
                                if (result.customAnimation === 'starfall') {
                                    this.showSquareEffect(result.title, result.message, () => {
                                        // Start the star animation when popup is dismissed
                                        this.animationEngine.animateStarfall(() => {
                                            this.endTurn();
                                        });
                                    });
                                } else if (result.customAnimation === 'viewAhead') {
                                    // Show the View Ahead modal with next three tiles
                                    this.showViewAheadModal(() => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'fairy') {
                                    // Show popup briefly, then start fairy animation
                                    this.showSquareEffect(result.title, result.message);
                                    setTimeout(() => {
                                        // Close modal and start fairy animation
                                        hideModal('squareModal');
                                        this.animationEngine.animateFairy(() => {
                                            // After fairy animation, show continue button
                                            this.showFairyContinueModal(() => {
                                                this.endTurn();
                                            });
                                        });
                                    }, 1500); // Show popup for 1.5 seconds then start animation
                                } else if (result.customAnimation === 'pickCard') {
                                    // Show the Pick a Card modal with interactive cards
                                    this.showPickCardModal(() => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'spinToken') {
                                    // Show the Spin Token modal with interactive spinner
                                    this.showSpinTokenModal(() => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'mysteryBag') {
                                    // Show the Mystery Bag modal with interactive backpack
                                    this.showMysteryBagModal(() => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'tapRace') {
                                    // Show the Tap Race mini-game with personas for risk calculation
                                    this.showTapRaceModal(result.personas, () => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'quickAim') {
                                    // Show the Quick Aim mini-game with arrow shooting
                                    this.showQuickAimModal(result.personas, () => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'memoryMatch') {
                                    // Show the Memory Match mini-game with persona-themed cards
                                    this.showMemoryMatchModal(result.personas, () => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'dodgeStar') {
                                    // Show the Collect Star mini-game with falling stars and shields
                                    this.showDodgeStarModal(result.personas, () => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'balloonBurst') {
                                    // Show the Balloon Burst mini-game with floating balloons
                                    this.showBalloonBurstModal(result.personas, () => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'colorSequence') {
                                    // Show the Color Sequence mini-game with memory challenge
                                    this.showColorSequenceModal(result.personas, () => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'stormShift') {
                                    // Show the Storm Shift animation with tile swapping
                                    this.showStormShiftModal(() => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'tradePlaces') {
                                    // Show the Trade Places phantom interaction
                                    this.showTradePlacesModal(() => {
                                        this.endTurn();
                                    });
                                } else if (result.customAnimation === 'doubleTrouble') {
                                    // Show the Double Trouble dice effect
                                    this.showDoubleTroubleModal(() => {
                                        this.endTurn();
                                    });
                                } else {
                            this.showSquareEffect(result.title, result.message);
                            if (result.debuff) {
                                this.addDebuff(result.debuff);
                            }
                            setTimeout(() => this.endTurn(), 2000);
                                }
                            }
                        } else {
                            this.endTurn();
                        }
                    });
            }
            
            endTurn() {
                // Update turn counter
                this.gameState.turn++;
                
                // Process debuffs (reduce duration, apply effects)
                this.processDebuffs();
                
                // Re-enable dice rolling
                this.gameState.canRoll = true;
                document.getElementById('rollDiceBtn').disabled = false;
                
                // Update UI
                this.updateGameStats();
                this.updateDebuffsDisplay();
                
                // Apply dice glow if double roll is active
                this.updateDiceGlow();
                
                // Debug check after turn end
                setTimeout(() => this.checkDiceButtonState(), 50);
                
                console.log(`Turn ${this.gameState.turn} - Player at position ${this.gameState.currentPosition}`);
            }
            
            showPhantomPreview(callback) {
                console.log('üëª Starting phantom preview (3 seconds) - shown every 5th roll');
                
                // Create ghost.png flying across screen
                const ghost = document.createElement('img');
                ghost.src = 'Assets/ghost.png';
                ghost.style.cssText = `
                    position: fixed;
                    width: 80px;
                    height: 80px;
                    object-fit: contain;
                    z-index: 1000;
                    pointer-events: none;
                    transition: none;
                `;
                ghost.onerror = () => {
                    // Fallback if ghost.png doesn't load
                    ghost.innerHTML = 'üëª';
                    ghost.style.fontSize = '60px';
                    ghost.style.textAlign = 'center';
                    ghost.style.lineHeight = '80px';
                };
                document.body.appendChild(ghost);
                
                // Random flight pattern for 3 seconds
                let animationCount = 0;
                const maxAnimations = 15; // 3 seconds / 200ms intervals
                
                const flyRandomly = () => {
                    if (animationCount >= maxAnimations) {
                        // Remove ghost and continue
                        if (ghost.parentNode) {
                            ghost.parentNode.removeChild(ghost);
                        }
                        console.log('üëª Phantom preview complete, continuing with dice roll');
                        if (callback) callback();
                        return;
                    }
                    
                    // Random position on screen
                    const x = Math.random() * (window.innerWidth - 80);
                    const y = Math.random() * (window.innerHeight - 80);
                    
                    ghost.style.left = x + 'px';
                    ghost.style.top = y + 'px';
                    ghost.style.transition = 'all 0.2s ease-in-out';
                    
                    animationCount++;
                    setTimeout(flyRandomly, 200);
                };
                
                // Start random flight
                flyRandomly();
            }
            
            updateDiceGlow() {
                const dice = document.getElementById('dice');
                const doubleRollEffect = this.gameState.activeDebuffs.find(d => d.type === 'doubleRoll');
                
                // Remove existing x2 badge
                const existingBadge = document.getElementById('diceMultiplierBadge');
                if (existingBadge) {
                    existingBadge.remove();
                }
                
                if (doubleRollEffect) {
                    // Apply glowing effect
                    dice.style.animation = 'diceGlow 2s infinite alternate';
                    dice.style.filter = 'drop-shadow(0 0 20px #fbbf24)';
                    dice.style.color = '#fbbf24';
                    
                    // Add x2 badge near dice
                    const badge = document.createElement('div');
                    badge.id = 'diceMultiplierBadge';
                    badge.style.cssText = `
                        position: absolute;
                        top: -10px;
                        right: -10px;
                        background: #fbbf24;
                        color: white;
                        border-radius: 50%;
                        width: 24px;
                        height: 24px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 0.8rem;
                        font-weight: bold;
                        z-index: 1000;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    `;
                    badge.textContent = 'x2';
                    
                    const diceContainer = dice.parentElement;
                    if (diceContainer) {
                        diceContainer.style.position = 'relative';
                        diceContainer.appendChild(badge);
                    }
                } else {
                    // Remove glowing effect
                    dice.style.animation = '';
                    dice.style.filter = '';
                    dice.style.color = '';
                }
            }
            
            addDebuff(debuff) {
                this.gameState.activeDebuffs.push({
                    ...debuff,
                    id: Date.now() + Math.random(),
                    turnsRemaining: debuff.duration || 3
                });
                this.updateDebuffsDisplay();
            }
            
            processDebuffs() {
                this.gameState.activeDebuffs = this.gameState.activeDebuffs.filter(debuff => {
                    debuff.turnsRemaining--;
                    return debuff.turnsRemaining > 0;
                });
            }
            
            renderBoard() {
                const boardElement = document.getElementById('gameBoard');
                boardElement.innerHTML = '';
                
                // Create all 50 squares
                for (let i = 0; i < 50; i++) {
                    const square = this.gameState.board.squares[i];
                    const squareElement = document.createElement('div');
                    squareElement.classList.add('board-square', `square-${square.type}`);
                    squareElement.textContent = '';
                    squareElement.dataset.position = i + 1;
                    squareElement.dataset.number = i + 1;
                    
                    // Add special styling for start and finish
                    if (i === 0) {
                        squareElement.classList.add('square-start');
                        squareElement.dataset.number = 'START';
                    } else if (i === 49) {
                        squareElement.classList.add('square-finish');
                        squareElement.dataset.number = 'FINISH';
                    }
                    
                    // Position square in snaking pattern
                    const row = Math.floor(i / 10);
                    const col = row % 2 === 0 ? i % 10 : 9 - (i % 10);
                    
                    squareElement.style.gridRow = 5 - row;
                    squareElement.style.gridColumn = col + 1;
                    
                    boardElement.appendChild(squareElement);
                }
                
                // Add ladders and chutes
                this.renderLaddersAndChutes();
            }
            
            renderLaddersAndChutes() {
                const boardElement = document.getElementById('gameBoard');
                
                // Add ladders with enhanced visuals based on direction
                this.gameState.board.ladders.forEach(ladder => {
                    // Safety check: Skip any ladders with length less than 6 squares
                    const ladderLength = ladder.end - ladder.start;
                    if (ladderLength < 6) {
                        console.warn(`üõë Skipping invalid short ladder: ${ladder.start} ‚Üí ${ladder.end} (length: ${ladderLength})`);
                        return;
                    }
                    
                    const ladderElement = document.createElement('div');
                    ladderElement.classList.add('ladder');
                    
                    const startPos = this.getSquarePosition(ladder.start);
                    const endPos = this.getSquarePosition(ladder.end);
                    
                    // Calculate center points of squares
                    const startX = startPos.x + 40; // Center of square (80px/2)
                    const startY = startPos.y + 40;
                    const endX = endPos.x + 40;
                    const endY = endPos.y + 40;
                    
                    // Calculate distance and angle
                    const deltaX = endX - startX;
                    const deltaY = endY - startY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
                    
                    // Determine direction and apply appropriate styling
                    const direction = this.boardGenerator.getLadderDirection(ladder.start, ladder.end);
                    
                    if (direction === 'vertical') {
                        // Simple vertical ladder
                        ladderElement.classList.add('ladder-vertical');
                        ladderElement.style.width = '12px';
                        ladderElement.style.height = `${distance}px`;
                    } else if (direction === 'diagonal-3row') {
                        // Enhanced 3-row diagonal ladder (wider and more prominent)
                        ladderElement.classList.add('ladder-diagonal');
                        ladderElement.style.width = `${distance}px`;
                        ladderElement.style.height = '20px'; // Wider for 3-row spans
                        ladderElement.style.boxShadow = '0 4px 12px rgba(34, 197, 94, 0.4)'; // More prominent
                    } else {
                        // Regular diagonal ladder
                        ladderElement.classList.add('ladder-diagonal');
                        ladderElement.style.width = `${distance}px`;
                        ladderElement.style.height = '16px';
                    }
                    
                    // Position and rotate the ladder
                    ladderElement.style.left = `${startX}px`;
                    ladderElement.style.top = `${startY}px`;
                    ladderElement.style.transformOrigin = '0 50%';
                    ladderElement.style.transform = `rotate(${angle}deg)`;
                    ladderElement.style.zIndex = '15';
                    
                    console.log(`ü™ú Drew ${direction} ladder from ${ladder.start} to ${ladder.end} - angle: ${angle.toFixed(1)}¬∞, distance: ${distance.toFixed(1)}px`);
                    
                    boardElement.appendChild(ladderElement);
                });
                
                // Add chutes with enhanced visuals based on direction
                this.gameState.board.chutes.forEach(chute => {
                    // Safety check: Skip any chutes with length less than 6 squares
                    const chuteLength = chute.start - chute.end;
                    if (chuteLength < 6) {
                        console.warn(`üõë Skipping invalid short chute: ${chute.start} ‚Üí ${chute.end} (length: ${chuteLength})`);
                        return;
                    }
                    
                    const chuteElement = document.createElement('div');
                    chuteElement.classList.add('chute');
                    
                    const startPos = this.getSquarePosition(chute.start);
                    const endPos = this.getSquarePosition(chute.end);
                    
                    // Calculate center points of squares
                    const startX = startPos.x + 40; // Center of square (80px/2)
                    const startY = startPos.y + 40;
                    const endX = endPos.x + 40;
                    const endY = endPos.y + 40;
                    
                    // Calculate distance and angle
                    const deltaX = endX - startX;
                    const deltaY = endY - startY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
                    
                    // Determine direction and apply appropriate styling
                    const direction = this.boardGenerator.getLadderDirection(chute.start, chute.end);
                    
                    if (direction === 'vertical') {
                        // Simple vertical slide
                        chuteElement.classList.add('chute-vertical');
                        chuteElement.style.width = '18px';
                        chuteElement.style.height = `${distance}px`;
                    } else if (direction === 'diagonal-3row') {
                        // Enhanced 3-row diagonal chute (wider and more prominent)
                        chuteElement.classList.add('chute-diagonal');
                        chuteElement.style.width = `${distance}px`;
                        chuteElement.style.height = '24px'; // Wider for 3-row spans
                        chuteElement.style.boxShadow = '0 4px 15px rgba(239, 68, 68, 0.5)'; // More prominent red glow
                    } else {
                        // Regular diagonal chute
                        chuteElement.classList.add('chute-diagonal');
                        chuteElement.style.width = `${distance}px`;
                        chuteElement.style.height = '20px';
                    }
                    
                    // Position and rotate the chute
                    chuteElement.style.left = `${startX}px`;
                    chuteElement.style.top = `${startY}px`;
                    chuteElement.style.transformOrigin = '0 50%';
                    chuteElement.style.transform = `rotate(${angle}deg)`;
                    chuteElement.style.zIndex = '15';
                    
                    console.log(`üõù Drew ${direction} chute from ${chute.start} to ${chute.end} - angle: ${angle.toFixed(1)}¬∞, distance: ${distance.toFixed(1)}px`);
                    
                    boardElement.appendChild(chuteElement);
                });
            }
            
            getSquarePosition(squareNumber) {
                // Convert square number (1-50) to array index (0-49)
                const index = squareNumber - 1;
                const row = Math.floor(index / 10);
                
                // Calculate column based on row direction
                // Even rows (0, 2, 4): left to right
                // Odd rows (1, 3): right to left (zigzag pattern)
                let col;
                if (row % 2 === 0) {
                    // Even rows: left to right (normal order)
                    col = index % 10;
                } else {
                    // Odd rows: right to left (reverse order)
                    col = 9 - (index % 10);
                }
                
                // Get the current CSS variable values
                const squareSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--square-size'));
                const gapSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap-size'));
                
                return {
                    x: col * (squareSize + gapSize),
                    y: (4 - row) * (squareSize + gapSize)
                };
            }
            
            positionPlayer() {
                const playerElement = document.getElementById('playerPiece');
                
                // Handle starting position (position 0 = off the board)
                if (this.gameState.currentPosition === 0) {
                    // Hide the player piece when at position 0 (starting position)
                    playerElement.style.display = 'none';
                    return;
                } else {
                    // Show the player piece when on the board
                    playerElement.style.display = 'flex';
                }
                
                const position = this.getSquarePosition(this.gameState.currentPosition);
                
                // Center the player piece on the square
                const squareSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--square-size'));
                const offset = 5; // Small offset to center nicely
                playerElement.style.left = `${position.x + offset}px`;
                playerElement.style.top = `${position.y + offset}px`;
                
                // Update player appearance to use the selected character image
                if (this.character.image) {
                    // Clear any existing background and create img element if not exists
                    playerElement.style.backgroundImage = 'none';
                    playerElement.style.backgroundColor = 'transparent';
                    playerElement.textContent = '';
                    
                    // Check if img element already exists
                    let img = playerElement.querySelector('img');
                    if (!img) {
                        img = document.createElement('img');
                        img.style.cssText = `
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: 50%;
                            pointer-events: none;
                        `;
                        playerElement.appendChild(img);
                    }
                    img.src = this.character.image;
                    img.alt = 'Player Character';
                } else {
                    // Remove img element if exists and use gradient background
                    const img = playerElement.querySelector('img');
                    if (img) img.remove();
                    
                    playerElement.style.backgroundImage = 'none';
                    playerElement.style.background = `radial-gradient(circle, ${this.character.color}, ${this.adjustBrightness(this.character.color, -0.3)})`;
                    playerElement.textContent = '';
                }
                playerElement.style.border = `3px solid ${this.character.color}`;
            }
            
            updateGameStats() {
                document.getElementById('currentTurn').textContent = this.gameState.turn;
                document.getElementById('currentPosition').textContent = this.gameState.currentPosition;
                document.getElementById('strengthScore').textContent = this.gameState.strengthScore;
            }
            
            updatePersonaDisplay() {
                const display = document.getElementById('personaDisplay');
                const traits = {
                    personality: { tactician: 'Tactician', daredevil: 'Daredevil' },
                    playstyle: { lucky: 'Lucky', persistent: 'Persistent' },
                    movement: { sprinter: 'Sprinter', jumper: 'Jumper' }
                };
                
                display.innerHTML = Object.entries(this.personas).map(([type, value]) => `
                    <div class="persona-trait">
                        <span class="trait-name">${traits[type][value]}</span>
                    </div>
                `).join('');
            }
            
            updateDebuffsDisplay() {
                const display = document.getElementById('debuffsList');
                
                if (this.gameState.activeDebuffs.length === 0) {
                    display.innerHTML = '<div style="text-align: center; color: #6b7280; font-size: 0.9rem;">No active effects</div>';
                } else {
                    display.innerHTML = this.gameState.activeDebuffs.map(effect => {
                        const isPositive = effect.type === 'prevention';
                        const bgColor = isPositive ? '#f0fdf4' : '#fef2f2';
                        const borderColor = isPositive ? '#bbf7d0' : '#fecaca';
                        
                        return `
                            <div class="debuff-item" style="background: ${bgColor}; border-color: ${borderColor};">
                                <div class="debuff-name">${effect.name}</div>
                                <div class="debuff-description">${effect.description}</div>
                            <div style="font-size: 0.8rem; color: #6b7280; margin-top: 0.25rem;">
                                    ${effect.turnsRemaining} turns remaining
                            </div>
                        </div>
                        `;
                    }).join('');
                }
            }
            
            startGameTimer() {
                setInterval(() => {
                    if (this.gameState.isPlaying) {
                        this.gameState.gameTime = Date.now() - this.gameState.startTime;
                        const minutes = Math.floor(this.gameState.gameTime / 60000);
                        const seconds = Math.floor((this.gameState.gameTime % 60000) / 1000);
                        document.getElementById('gameTime').textContent = 
                            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            }
            
            showSquareEffect(title, message, callback = null) {
                console.log(`ü™ü ShowSquareEffect called - title: ${title}, callback:`, callback);
                document.getElementById('modalTitle').innerHTML = title;
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.1rem; margin-bottom: 1rem;">${message}</div>
                    </div>
                `;
                
                // Store callback for when modal is closed
                this.pendingModalCallback = callback;
                console.log(`üíæ Stored pendingModalCallback:`, this.pendingModalCallback);
                
                // Show the default modal footer for regular square effects
                document.getElementById('defaultModalFooter').style.display = 'block';
                
                showModal('squareModal');
            }

            showViewAheadModal(callback = null) {
                console.log(`üîÆ ShowViewAheadModal called - getting next three tiles`);
                
                // Get the next three tiles from current position
                const nextTiles = this.getNextThreeTiles();
                const hasBadTiles = this.hasBadEventsInTiles(nextTiles);
                
                document.getElementById('modalTitle').textContent = 'üëÄ View Ahead';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.1rem; margin-bottom: 1.5rem;">You scout the path ahead and see what's coming next!</div>
                        
                        <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-bottom: 1.5rem;">
                            ${nextTiles.map(tile => this.createTilePreviewCard(tile)).join('')}
                        </div>
                        
                        ${hasBadTiles ? `
                            <div style="
                                background: #fef2f2;
                                border: 1px solid #fecaca;
                                border-radius: 8px;
                                padding: 1rem;
                                margin-bottom: 1.5rem;
                                text-align: left;
                            ">
                                <div style="font-weight: 600; color: #dc2626; margin-bottom: 0.5rem;">‚ö†Ô∏è Warning: Dangerous tiles ahead!</div>
                                <div style="font-size: 0.9rem; color: #991b1b; margin-bottom: 0.75rem;">
                                    You can see potentially harmful effects on your path.
                                </div>
                                <label style="display: flex; align-items: center; cursor: pointer; font-size: 0.9rem;">
                                    <input type="checkbox" id="preventBadEventsCheckbox" style="margin-right: 0.5rem;">
                                    <span>üõ°Ô∏è Use foresight to prevent bad events on these 3 tiles</span>
                                </label>
                            </div>
                        ` : ''}
                    </div>
                `;
                
                // Store callback for when modal is closed
                this.pendingModalCallback = callback;
                console.log(`üíæ Stored pendingModalCallback:`, this.pendingModalCallback);
                
                // Store the next tiles for the prevention logic
                this.currentPreventionTiles = nextTiles;
                
                // Show the default modal footer (keep it visible)
                document.getElementById('defaultModalFooter').style.display = 'block';
                
                showModal('squareModal');
            }

            getNextThreeTiles() {
                const currentPos = this.gameState.currentPosition;
                const nextTiles = [];
                
                for (let i = 1; i <= 3; i++) {
                    const nextPos = currentPos + i;
                    if (nextPos <= 50) {
                        const square = this.gameState.board.squares[nextPos - 1];
                        nextTiles.push({
                            position: nextPos,
                            square: square,
                            ...this.getTileDisplayInfo(square, nextPos)
                        });
                    }
                }
                
                return nextTiles;
            }

            getTileDisplayInfo(square, position) {
                // Handle special squares
                if (position === 50) {
                    return {
                        icon: 'üèÅ',
                        title: 'FINISH - Victory!',
                        description: 'Reach this square to win the game!'
                    };
                }
                
                // Handle ladder and chute squares
                if (square.ladder) {
                    return {
                        icon: 'ü™ú',
                        title: `Ladder to ${square.ladder.end}`,
                        description: 'Climb up to a higher square!'
                    };
                }
                
                if (square.chute) {
                    return {
                        icon: 'üõù',
                        title: `Chute to ${square.chute.end}`,
                        description: 'Slide down to a lower square!'
                    };
                }
                
                // Handle regular square types
                const typeInfo = {
                    safe: { icon: 'üõ°Ô∏è', titles: ['üò¥ Safe Rest', 'üëÄ View Ahead', '<img src="Assets/star.png" style="width: 16px; height: 16px; object-fit: contain; vertical-align: middle;" onerror="this.outerHTML=\'‚ú®\'"> Freebie'] },
                    animation: { icon: 'üé≠', titles: ['üÉè Pick a Card', 'üé∞ Spin Token', '<img src="Assets/backpack.png" style="width: 16px; height: 16px; object-fit: contain; vertical-align: middle;" onerror="this.outerHTML=\'üéí\'"> Mystery Bag'] },
                    movement: { icon: 'üîÑ', titles: ['üéà Balloon Burst'] },
                    battle: { icon: '‚öîÔ∏è', titles: ['‚öîÔ∏è Battle Challenge'] },
                    random: { icon: 'üé≤', titles: ['üé≤ Random Event'] },
                    persona: { icon: 'üë§', titles: ['üë§ Persona Challenge'] }
                };
                
                const info = typeInfo[square.type] || { icon: '‚ùì', titles: ['‚ùì Unknown'] };
                const randomTitle = info.titles[Math.floor(Math.random() * info.titles.length)];
                
                return {
                    icon: info.icon,
                    title: randomTitle,
                    description: this.squareSystem.getSquareDescription(square)
                };
            }

            createTilePreviewCard(tile) {
                const isBadTile = this.isBadTile(tile);
                const borderColor = isBadTile ? '#ef4444' : 'var(--primary-color)';
                const bgColor = isBadTile ? '#fef2f2' : 'white';
                
                return `
                    <div style="
                        background: ${bgColor};
                        border: 2px solid ${borderColor};
                        border-radius: 12px;
                        padding: 1rem;
                        width: 140px;
                        text-align: center;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                        transition: transform 0.2s ease;
                        ${isBadTile ? 'position: relative;' : ''}
                    " onmouseover="this.style.transform='scale(1.05)'" 
                       onmouseout="this.style.transform='scale(1)'">
                        
                        ${isBadTile ? '<div style="position: absolute; top: -8px; right: -8px; background: #ef4444; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold;">!</div>' : ''}
                        
                        <div style="
                            background: var(--light-color);
                            border-radius: 8px;
                            padding: 0.5rem;
                            margin-bottom: 0.5rem;
                            font-size: 0.8rem;
                            color: var(--primary-color);
                            font-weight: 600;
                        ">
                            Square ${tile.position}
                        </div>
                        
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">
                            ${tile.icon}
                        </div>
                        
                        <div style="
                            font-size: 0.9rem;
                            font-weight: 600;
                            color: var(--text-color);
                            margin-bottom: 0.5rem;
                            line-height: 1.2;
                        ">
                            ${tile.title}
                        </div>
                        
                        <div style="
                            font-size: 0.75rem;
                            color: #64748b;
                            line-height: 1.3;
                        ">
                            ${tile.description}
                        </div>
                    </div>
                `;
            }

            showPickCardModal(callback = null) {
                console.log(`üÉè ShowPickCardModal called`);
                
                // Generate three random cards
                const cards = this.generateThreeCards();
                
                document.getElementById('modalTitle').textContent = 'üÉè Pick a Card';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.1rem; margin-bottom: 1.5rem;">Pick one card - but escape the penalty one comes with.</div>
                        
                        <div id="cardContainer" style="display: flex; gap: 2rem; justify-content: center; align-items: flex-start; margin-bottom: 2rem; flex-wrap: nowrap;">
                            ${cards.map((card, index) => this.createPlayingCard(card, index)).join('')}
                        </div>
                        
                        <div id="outcomeText" style="
                            font-size: 1rem;
                            margin-bottom: 1.5rem;
                            min-height: 2rem;
                            color: var(--text-color);
                            font-weight: 600;
                        "></div>
                        
                        <button id="continueButton" style="
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                            display: none;
                        " onmouseover="this.style.background='var(--secondary-color)'" 
                           onmouseout="this.style.background='var(--primary-color)'">
                            Continue
                        </button>
                    </div>
                `;
                
                // Store callback and card data
                this.pendingModalCallback = callback;
                this.currentCards = cards;
                this.cardSelected = false;
                
                // Hide the default modal footer for custom cards modal
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Use Memory Match approach for reliable card handling
                setTimeout(() => {
                    console.log(`üÉè Setting up ${cards.length} cards with Memory Match approach`);
                    
                    cards.forEach((card, index) => {
                        const cardElement = document.getElementById(`card-${index}`);
                        console.log(`üÉè Card ${index} element:`, cardElement);
                        
                        if (cardElement) {
                            // Set data attribute for consistent selection (like Memory Match)
                            cardElement.setAttribute('data-card-index', index);
                            
                            // Single clean click handler (like Memory Match)
                            cardElement.onclick = () => {
                                console.log(`üÉè Card ${index} clicked! Selected: ${this.cardSelected}`);
                                if (!this.cardSelected) {
                                    this.cardSelected = true;
                                    this.handleCardSelection(index);
                                }
                            };
                        }
                    });
                }, 100);

            }

            generateThreeCards() {
                const cardAssets = ['card1.png', 'card2.png', 'card3.png'];
                
                // Create exactly one of each outcome type
                const outcomes = [
                    {
                        type: 'safe',
                        title: 'üÉè Pick a Card - Safe!',
                        message: 'You picked the right card! Nothing bad happens.',
                        effect: null
                    },
                    {
                        type: 'bonus',
                        title: 'üÉè Pick a Card - Bonus!',
                        message: 'Lucky pick! You get to move forward an extra space next turn!',
                        effect: {
                            type: 'bonusMove',
                            name: 'Bonus Movement',
                            description: 'Move forward an extra space next turn',
                            duration: 1
                        }
                    },
                    {
                        type: 'punished',
                        title: 'üÉè Pick a Card - Punished!',
                        message: 'Wrong card! You lose 10 points.',
                        effect: 'lose10Points'
                    }
                ];
                
                // Shuffle the outcomes to randomize positions
                const shuffledOutcomes = [...outcomes].sort(() => Math.random() - 0.5);
                
                // Create cards with random assets but fixed outcome distribution
                const cards = shuffledOutcomes.map((outcome, index) => {
                    const randomAsset = cardAssets[Math.floor(Math.random() * cardAssets.length)];
                    return {
                        asset: randomAsset,
                        displayName: randomAsset.replace('.png', '').toUpperCase(),
                        outcome: outcome
                    };
                });
                
                return cards;
            }

            createPlayingCard(card, index) {
                return `
                    <div class="card-wrapper" style="
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 0.75rem;
                    ">
                        <div id="card-${index}" class="playing-card" style="
                            width: 120px;
                            height: 168px;
                            border: 2px solid #374151;
                            border-radius: 12px;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            perspective: 1000px;
                            position: relative;
                            transform-style: preserve-3d;
                            pointer-events: auto;
                            user-select: none;
                            display: block;
                            z-index: 10;
                        ">
                            
                            <!-- Card Back (initially visible) -->
                            <div class="card-back" style="
                                position: absolute;
                                width: 100%;
                                height: 100%;
                                background: linear-gradient(45deg, #1e40af, #3730a3);
                                border-radius: 10px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                backface-visibility: hidden;
                                transform: rotateY(0deg);
                                pointer-events: none;
                            ">
                                <div style="
                                    width: 80px;
                                    height: 120px;
                                    background: repeating-linear-gradient(
                                        45deg,
                                        #2563eb,
                                        #2563eb 4px,
                                        #1d4ed8 4px,
                                        #1d4ed8 8px
                                    );
                                    border-radius: 6px;
                                    border: 2px solid #1e40af;
                                    pointer-events: none;
                                "></div>
                            </div>
                            
                            <!-- Card Front (initially hidden) -->
                            <div class="card-front" style="
                                position: absolute;
                                width: 100%;
                                height: 100%;
                                background: white;
                                border-radius: 10px;
                                backface-visibility: hidden;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                transform: rotateY(-180deg);
                                box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
                                pointer-events: none;
                            ">
                                <img src="Assets/${card.asset}" style="
                                    width: 100px;
                                    height: 140px;
                                    object-fit: contain;
                                    border-radius: 6px;
                                    pointer-events: none;
                                " onerror="this.outerHTML='<div style=\\"font-size: 1.2rem; font-weight: 700; color: #374151; text-align: center; pointer-events: none;\\">${card.displayName}</div>'">
                            </div>
                        </div>
                        
                        <!-- Card Label -->
                        <div class="card-label" style="
                            font-size: 1rem;
                            font-weight: 600;
                            color: var(--text-color);
                            text-align: center;
                            pointer-events: none;
                            user-select: none;
                        ">CARD${index + 1}</div>
                    </div>
                `;
            }

            handleCardSelection(selectedIndex) {
                this.cardSelected = true;
                console.log(`üÉè Card ${selectedIndex} selected`);
                
                // Flip the selected card first
                this.flipPickCard(selectedIndex, () => {
                    // Show the outcome message
                    const selectedCard = this.currentCards[selectedIndex];
                    const outcomeElement = document.getElementById('outcomeText');
                    if (outcomeElement) {
                        outcomeElement.innerHTML = selectedCard.outcome.message;
                    }
                    
                    // Apply the effect
                    this.applyCardEffect(selectedCard.outcome);
                    
                    // Flip the other two cards after a short delay
                    setTimeout(() => {
                        this.currentCards.forEach((card, index) => {
                            if (index !== selectedIndex) {
                                this.flipPickCard(index);
                            }
                        });
                        
                        // Show the continue button after all cards are flipped
                        setTimeout(() => {
                            const continueBtn = document.getElementById('continueButton');
                            if (continueBtn) {
                                continueBtn.style.display = 'block';
                                continueBtn.onclick = () => {
                                    // Restore default footer for future modals
                                    document.getElementById('defaultModalFooter').style.display = 'block';
                                    hideModal('squareModal');
                                };
                            }
                        }, 1000);
                    }, 1000);
                });
            }

            flipPickCard(cardIndex, callback = null) {
                // Use the same method as Memory Match for consistency
                const cardElement = document.querySelector(`[data-card-index="${cardIndex}"]`);
                console.log(`üÉè Flipping card ${cardIndex} (Memory Match style), element:`, cardElement);
                if (cardElement) {
                    cardElement.style.transform = 'rotateY(180deg)';
                    cardElement.style.cursor = 'default';
                    
                    if (callback) {
                        setTimeout(callback, 600); // Wait for flip animation to complete
                    }
                } else {
                    console.error(`üÉè Could not find card element: card-${cardIndex}`);
                    if (callback) callback(); // Still call callback even if card not found
                }
            }

            applyCardEffect(outcome) {
                if (outcome.effect === 'lose10Points') {
                    // Subtract 10 points from strength score
                    this.gameState.strengthScore = Math.max(0, this.gameState.strengthScore - 10);
                    this.updateGameStats();
                } else if (outcome.effect && outcome.effect.type === 'bonusMove') {
                    // Add the bonus movement effect
                    this.addActiveEffect(outcome.effect);
                }
                // Safe outcome has no effect to apply
            }

            showFairyContinueModal(callback = null) {
                console.log('üßö‚Äç‚ôÄÔ∏è Showing fairy continue modal');
                
                document.getElementById('modalTitle').innerHTML = '<img src="Assets/star.png" style="width: 24px; height: 24px; object-fit: contain; vertical-align: middle;" onerror="this.outerHTML=\'‚ú®\'"> Magical Effects Complete';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.1rem; margin-bottom: 1.5rem; color: var(--success-color);">
                            üßö‚Äç‚ôÄÔ∏è The fairy's magic has taken effect!
                        </div>
                        <div style="font-size: 0.9rem; color: var(--text-color); margin-bottom: 1.5rem;">
                            All debuffs have been removed and you've been blessed with bonus points!
                        </div>
                        <button id="fairyContinueButton" style="
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                            font-family: 'Space Grotesk', sans-serif;
                        " onmouseover="this.style.background='var(--secondary-color)'" 
                           onmouseout="this.style.background='var(--primary-color)'">
                            Continue <img src="Assets/star.png" style="width: 16px; height: 16px; object-fit: contain; vertical-align: middle;" onerror="this.outerHTML='‚ú®'">
                        </button>
                    </div>
                `;
                
                // Store callback
                this.pendingModalCallback = callback;
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Setup continue button click handler
                setTimeout(() => {
                    const continueBtn = document.getElementById('fairyContinueButton');
                    if (continueBtn) {
                        continueBtn.focus();
                        continueBtn.onclick = () => {
                            // NOW add the 10 points when continue is pressed
                            console.log('üßö‚Äç‚ôÄÔ∏è Adding 10 points after continue clicked');
                            if (window.gameInstance && window.gameInstance.gameState) {
                                window.gameInstance.gameState.strengthScore += 10;
                                window.gameInstance.updateGameStats();
                            }
                            
                            // Restore default footer for future modals
                            document.getElementById('defaultModalFooter').style.display = 'block';
                            hideModal('squareModal');
                        };
                    }
                }, 100);
            }

            showSpinTokenModal(callback = null) {
                console.log('üé∞ ShowSpinTokenModal called');
                
                document.getElementById('modalTitle').textContent = 'üé∞ Spin Token';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.1rem; margin-bottom: 1.5rem;">The token spins you 2 spaces forward/backward!</div>
                        
                        <div style="display: flex; justify-content: center; margin-bottom: 2rem;">
                            <div id="spinnerContainer" style="position: relative; width: 200px; height: 200px;">
                                <!-- Spinner wheel -->
                                <svg width="200" height="200" viewBox="0 0 200 200">
                                    <!-- Green +2 segment (0¬∞ to 120¬∞) -->
                                    <path d="M 100 100 L 100 10 A 90 90 0 0 1 177.94 55 Z" 
                                          fill="#22c55e" stroke="white" stroke-width="3"/>
                                    <!-- Red -2 segment (120¬∞ to 240¬∞) -->  
                                    <path d="M 100 100 L 177.94 55 A 90 90 0 0 1 177.94 145 Z" 
                                          fill="#ef4444" stroke="white" stroke-width="3"/>
                                    <!-- Yellow 0 segment (240¬∞ to 360¬∞) -->
                                    <path d="M 100 100 L 177.94 145 A 90 90 0 0 1 100 10 Z" 
                                          fill="#eab308" stroke="white" stroke-width="3"/>
                                    
                                    <!-- Text labels -->
                                    <text x="100" y="45" text-anchor="middle" fill="white" font-size="18" font-weight="bold">+2</text>
                                    <text x="145" y="85" text-anchor="middle" fill="white" font-size="18" font-weight="bold">-2</text>
                                    <text x="145" y="125" text-anchor="middle" fill="white" font-size="18" font-weight="bold">0</text>
                                    
                                    <!-- Pointer at top -->
                                    <polygon points="100,5 105,15 95,15" fill="#374151" stroke="white" stroke-width="1"/>
                                    
                                    <!-- Center circle -->
                                    <circle cx="100" cy="100" r="8" fill="#374151" stroke="white" stroke-width="2"/>
                                </svg>
                            </div>
                        </div>
                        
                        <div id="spinInstructions" style="font-size: 1rem; margin-bottom: 1.5rem; color: var(--primary-color); font-weight: 600;">
                            Click the wheel to spin!
                        </div>
                        
                        <div id="spinResult" style="font-size: 1.2rem; font-weight: 600; margin-bottom: 1.5rem; min-height: 2rem; color: var(--text-color);"></div>
                    </div>
                `;
                
                // Store callback
                this.pendingModalCallback = callback;
                this.spinnerActive = false;
                this.spinnerResult = null;
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Setup spinner click handler
                setTimeout(() => {
                    const spinnerContainer = document.getElementById('spinnerContainer');
                    if (spinnerContainer) {
                        spinnerContainer.style.cursor = 'pointer';
                        spinnerContainer.onclick = () => {
                            if (!this.spinnerActive) {
                                this.startSpin();
                            }
                        };
                    }
                }, 100);
            }

            startSpin() {
                this.spinnerActive = true;
                const spinner = document.querySelector('#spinnerContainer svg');
                const instructions = document.getElementById('spinInstructions');
                
                if (!spinner) return;
                
                // Hide instructions
                instructions.textContent = 'Spinning...';
                spinner.style.cursor = 'default';
                
                // Determine final result (angles to align each segment center with top pointer)
                const results = [
                    { value: 2, angle: 300, color: '#22c55e', text: '+2 Forward!' },     // Green segment center to top
                    { value: -2, angle: 180, color: '#ef4444', text: '-2 Backward!' },   // Red segment center to top  
                    { value: 0, angle: 60, color: '#eab308', text: '0 Nothing!' }        // Yellow segment center to top
                ];
                
                const finalResult = results[Math.floor(Math.random() * 3)];
                this.spinnerResult = finalResult;
                
                // Add multiple full rotations + final position
                const finalAngle = (360 * 5) + finalResult.angle; // 5 full rotations + result
                
                // Spinning animation with easing
                spinner.style.transition = 'transform 2s cubic-bezier(0.4, 0.0, 0.2, 1)';
                spinner.style.transform = `rotate(${finalAngle}deg)`;
                
                // After spin completes
                setTimeout(() => {
                    this.showSpinResult();
                }, 2000);
            }

            showSpinResult() {
                const result = this.spinnerResult;
                const resultDiv = document.getElementById('spinResult');
                const instructions = document.getElementById('spinInstructions');
                
                if (resultDiv) {
                    resultDiv.innerHTML = `<span style="color: ${result.color};">${result.text}</span>`;
                    resultDiv.style.fontSize = '1.4rem';
                }
                
                if (instructions) {
                    instructions.style.display = 'none';
                }
                
                // Apply the result after a brief pause
                setTimeout(() => {
                    this.applySpinResult(result);
                }, 1000);
            }

            applySpinResult(result) {
                // Close modal first
                hideModal('squareModal');
                document.getElementById('defaultModalFooter').style.display = 'block';
                
                if (result.value === 0) {
                    // No movement, just end turn
                    setTimeout(() => {
                        if (this.pendingModalCallback) {
                            this.pendingModalCallback();
                        }
                    }, 500);
                } else {
                    // Move player with animation
                    const currentPos = this.gameState.currentPosition;
                    const newPos = Math.max(1, Math.min(50, currentPos + result.value));
                    
                    console.log(`üé∞ Spin result: ${result.value}, moving from ${currentPos} to ${newPos}`);
                    
                    // Start the appropriate movement animation
                    if (result.value > 0) {
                        this.animateSpinMovement(currentPos, newPos, 'rainbow', () => {
                            this.gameState.currentPosition = newPos;
                            this.positionPlayer();
                            if (this.pendingModalCallback) {
                                this.pendingModalCallback();
                            }
                        });
                    } else {
                        this.animateSpinMovement(currentPos, newPos, 'raincloud', () => {
                            this.gameState.currentPosition = newPos;
                            this.positionPlayer();
                            if (this.pendingModalCallback) {
                                this.pendingModalCallback();
                            }
                        });
                    }
                }
            }

            animateSpinMovement(fromPos, toPos, effectType, callback) {
                // First animate the player movement
                this.animationEngine.animatePlayerMovement(fromPos, toPos, () => {
                    // After movement, show the effect
                    const player = document.getElementById('playerPiece');
                    if (player) {
                        this.createSpinEffect(player, effectType, callback);
                    } else {
                        callback();
                    }
                }, true, effectType === 'rainbow' ? 'üåà' : '‚òÅÔ∏è');
            }

            createSpinEffect(playerElement, effectType, callback) {
                const playerRect = playerElement.getBoundingClientRect();
                const centerX = playerRect.left + playerRect.width / 2;
                const centerY = playerRect.top + playerRect.height / 2;
                
                if (effectType === 'rainbow') {
                    this.createRainbowEffect(centerX, centerY, callback);
                } else if (effectType === 'raincloud') {
                    this.createRainCloudEffect(centerX, centerY, callback);
                } else {
                    callback();
                }
            }

            createRainbowEffect(centerX, centerY, callback) {
                // Create rainbow arc above player
                const rainbow = document.createElement('div');
                rainbow.innerHTML = 'üåà';
                rainbow.style.position = 'fixed';
                rainbow.style.left = (centerX - 25) + 'px';
                rainbow.style.top = (centerY - 60) + 'px';
                rainbow.style.fontSize = '50px';
                rainbow.style.zIndex = '999';
                rainbow.style.pointerEvents = 'none';
                rainbow.style.opacity = '0';
                rainbow.style.transition = 'all 1s ease-in-out';
                
                document.body.appendChild(rainbow);
                
                // Animate rainbow appearance
                setTimeout(() => {
                    rainbow.style.opacity = '1';
                    rainbow.style.transform = 'scale(1.2)';
                }, 100);
                
                // Remove rainbow and callback
                setTimeout(() => {
                    rainbow.style.opacity = '0';
                    setTimeout(() => {
                        if (rainbow.parentNode) {
                            rainbow.parentNode.removeChild(rainbow);
                        }
                        callback();
                    }, 500);
                }, 1500);
            }

            createRainCloudEffect(centerX, centerY, callback) {
                // Create rain cloud above player
                const cloud = document.createElement('div');
                cloud.innerHTML = '‚òÅÔ∏è';
                cloud.style.position = 'fixed';
                cloud.style.left = (centerX - 25) + 'px';
                cloud.style.top = (centerY - 60) + 'px';
                cloud.style.fontSize = '50px';
                cloud.style.zIndex = '999';
                cloud.style.pointerEvents = 'none';
                cloud.style.opacity = '0';
                cloud.style.transition = 'all 1s ease-in-out';
                
                document.body.appendChild(cloud);
                
                // Animate cloud appearance
                setTimeout(() => {
                    cloud.style.opacity = '1';
                    cloud.style.transform = 'scale(1.2)';
                    
                    // Add some rain drops
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            this.createRainDrop(centerX, centerY - 40);
                        }, i * 200);
                    }
                }, 100);
                
                // Remove cloud and callback
                setTimeout(() => {
                    cloud.style.opacity = '0';
                    setTimeout(() => {
                        if (cloud.parentNode) {
                            cloud.parentNode.removeChild(cloud);
                        }
                        callback();
                    }, 500);
                }, 1500);
            }

            createRainDrop(startX, startY) {
                const drop = document.createElement('div');
                drop.innerHTML = 'üíß';
                drop.style.position = 'fixed';
                drop.style.left = (startX + (Math.random() * 60 - 30)) + 'px'; // Random spread
                drop.style.top = startY + 'px';
                drop.style.fontSize = '16px';
                drop.style.zIndex = '998';
                drop.style.pointerEvents = 'none';
                drop.style.transition = 'all 0.8s ease-in';
                
                document.body.appendChild(drop);
                
                // Animate drop falling
                setTimeout(() => {
                    drop.style.top = (startY + 80) + 'px';
                    drop.style.opacity = '0';
                }, 100);
                
                // Remove drop
                setTimeout(() => {
                    if (drop.parentNode) {
                        drop.parentNode.removeChild(drop);
                    }
                }, 1000);
            }

            showTapRaceModal(personas, callback = null) {
                console.log('‚öîÔ∏è ShowTapRaceModal called with personas:', personas);
                
                document.getElementById('modalTitle').textContent = '‚öîÔ∏è Tap Race Challenge';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem; height: 500px; position: relative;">
                        <div style="font-size: 1.2rem; margin-bottom: 1rem; font-weight: 600;">
                            Tap as fast as you can for 5 seconds!
                        </div>
                        
                        <!-- Timer Bar -->
                        <div id="timerBarContainer" style="
                            width: 100%; 
                            height: 20px; 
                            background: #e5e7eb; 
                            border-radius: 10px; 
                            margin-bottom: 2rem;
                            overflow: hidden;
                            position: relative;
                        ">
                            <div id="timerBar" style="
                                width: 100%; 
                                height: 100%; 
                                background: linear-gradient(90deg, #22c55e 0%, #eab308 50%, #ef4444 100%);
                                border-radius: 10px;
                                transition: width 0.1s linear;
                            "></div>
                            <div style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); line-height: 20px; font-size: 0.8rem; font-weight: 600; color: white;">
                                <span id="timerText">5.0s</span>
                            </div>
                        </div>
                        
                        <!-- Tap Counter -->
                        <div id="tapCounter" style="
                            font-size: 4rem; 
                            font-weight: bold; 
                            margin-bottom: 0.5rem;
                            color: var(--primary-color);
                            text-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
                            transition: all 0.1s ease;
                        ">0</div>
                        
                        <div style="font-size: 1rem; margin-bottom: 2rem; color: var(--text-color);">
                            Points Accumulated
                        </div>
                        
                        <!-- Outcome Dot (initially hidden) -->
                        <div id="outcomeDot" style="
                            width: 80px; 
                            height: 80px; 
                            border-radius: 50%; 
                            background: #6b7280; 
                            margin: 0 auto 1rem auto;
                            display: none;
                            transition: all 0.5s ease;
                            box-shadow: 0 0 30px rgba(107, 114, 128, 0.5);
                        "></div>
                        
                        <!-- Tap Zone (entire lower half) -->
                        <div id="tapZone" style="
                            position: absolute;
                            bottom: 0;
                            left: 0;
                            right: 0;
                            height: 60%;
                            background: linear-gradient(180deg, rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.3));
                            border: 3px dashed var(--primary-color);
                            border-radius: 20px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            user-select: none;
                            transition: background 0.1s ease;
                        ">
                            <div style="font-size: 2rem; font-weight: 600; color: var(--primary-color); pointer-events: none;">
                                TAP HERE!
                            </div>
                        </div>
                        
                        <!-- Instructions -->
                        <div id="raceInstructions" style="
                            position: absolute;
                            top: 180px;
                            left: 50%;
                            transform: translateX(-50%);
                            font-size: 1.2rem;
                            font-weight: 600;
                            color: var(--success-color);
                            z-index: 10;
                        ">Click anywhere in the blue zone to start!</div>
                        
                        <!-- Result Text -->
                        <div id="raceResult" style="
                            position: absolute;
                            bottom: 20px;
                            left: 50%;
                            transform: translateX(-50%);
                            font-size: 1.2rem;
                            font-weight: 600;
                            text-align: center;
                            min-height: 2rem;
                            width: 100%;
                        "></div>
                        
                        <!-- Continue Button (initially hidden) -->
                        <button id="raceContinueButton" style="
                            position: absolute;
                            bottom: 80px;
                            left: 50%;
                            transform: translateX(-50%);
                            display: none;
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 2rem;
                            border-radius: 8px;
                            font-size: 1.1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                            font-family: 'Space Grotesk', sans-serif;
                        " onmouseover="this.style.background='var(--secondary-color)'" 
                           onmouseout="this.style.background='var(--primary-color)'">
                            Continue
                        </button>
                    </div>
                `;
                
                // Store callback and game state
                this.pendingModalCallback = callback;
                this.racePersonas = personas;
                this.raceActive = false;
                this.raceStarted = false;
                this.tapCount = 0;
                this.raceTimeRemaining = 5000; // 5 seconds in milliseconds
                this.raceResult = null;
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Setup tap zone handler
                setTimeout(() => {
                    const tapZone = document.getElementById('tapZone');
                    if (tapZone) {
                        tapZone.onclick = (e) => {
                            e.preventDefault();
                            if (!this.raceStarted) {
                                this.startTapRace();
                            } else if (this.raceActive) {
                                this.registerTap();
                            }
                        };
                        
                        // Prevent context menu and other interactions
                        tapZone.oncontextmenu = (e) => e.preventDefault();
                        tapZone.ondragstart = (e) => e.preventDefault();
                        tapZone.onselectstart = (e) => e.preventDefault();
                    }
                }, 100);
            }

            startTapRace() {
                console.log('‚öîÔ∏è Starting Tap Race!');
                this.raceStarted = true;
                this.raceActive = true;
                this.tapCount = 0;
                
                const instructions = document.getElementById('raceInstructions');
                const tapZone = document.getElementById('tapZone');
                
                if (instructions) {
                    instructions.textContent = 'TAP! TAP! TAP!';
                    instructions.style.color = '#ef4444';
                    instructions.style.animation = 'pulse 0.5s infinite';
                }
                
                if (tapZone) {
                    tapZone.style.borderColor = '#ef4444';
                    const tapText = tapZone.querySelector('div');
                    if (tapText) {
                        tapText.textContent = 'KEEP TAPPING!';
                        tapText.style.color = '#ef4444';
                    }
                }
                
                // Start timer countdown
                this.runTapRaceTimer();
            }

            runTapRaceTimer() {
                const timerBar = document.getElementById('timerBar');
                const timerText = document.getElementById('timerText');
                const startTime = Date.now();
                const duration = 5000; // 5 seconds
                
                const updateTimer = () => {
                    if (!this.raceActive) return;
                    
                    const elapsed = Date.now() - startTime;
                    const remaining = Math.max(0, duration - elapsed);
                    const progress = remaining / duration;
                    
                    if (timerBar) {
                        timerBar.style.width = (progress * 100) + '%';
                    }
                    
                    if (timerText) {
                        timerText.textContent = (remaining / 1000).toFixed(1) + 's';
                    }
                    
                    if (remaining > 0) {
                        requestAnimationFrame(updateTimer);
                    } else {
                        this.endTapRace();
                    }
                };
                
                updateTimer();
            }

            registerTap() {
                if (!this.raceActive) return;
                
                this.tapCount++;
                const counter = document.getElementById('tapCounter');
                const tapZone = document.getElementById('tapZone');
                
                if (counter) {
                    counter.textContent = this.tapCount;
                    // Glow effect on tap
                    counter.style.textShadow = '0 0 30px rgba(59, 130, 246, 0.8)';
                    counter.style.transform = 'scale(1.05)';
                    
                    setTimeout(() => {
                        counter.style.textShadow = '0 0 20px rgba(59, 130, 246, 0.5)';
                        counter.style.transform = 'scale(1)';
                    }, 100);
                }
                
                if (tapZone) {
                    // Flash effect on tap
                    tapZone.style.background = 'linear-gradient(180deg, rgba(34, 197, 94, 0.2), rgba(34, 197, 94, 0.4))';
                    setTimeout(() => {
                        tapZone.style.background = 'linear-gradient(180deg, rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.3))';
                    }, 100);
                }
            }

            endTapRace() {
                console.log(`‚öîÔ∏è Tap Race ended! Final count: ${this.tapCount}`);
                this.raceActive = false;
                
                const instructions = document.getElementById('raceInstructions');
                const tapZone = document.getElementById('tapZone');
                const outcomeDot = document.getElementById('outcomeDot');
                
                // Hide instructions and tap zone
                if (instructions) {
                    instructions.style.display = 'none';
                }
                if (tapZone) {
                    tapZone.style.display = 'none';
                }
                
                // Calculate outcome based on personas
                const redProbability = this.calculateRedDotProbability(this.racePersonas);
                const isRedOutcome = Math.random() < redProbability;
                
                this.raceResult = {
                    taps: this.tapCount,
                    isRed: isRedOutcome,
                    points: isRedOutcome ? -this.tapCount : this.tapCount,
                    message: isRedOutcome ? 
                        `Red Dot! You lose ${this.tapCount} points. The phantom sucks them away!` :
                        `Green Dot! You keep all ${this.tapCount} points! Excellent work!`,
                    color: isRedOutcome ? '#ef4444' : '#22c55e'
                };
                
                // Show and animate the outcome dot
                if (outcomeDot) {
                    outcomeDot.style.display = 'block';
                    this.animateOutcomeDotReveal(outcomeDot, isRedOutcome);
                }
            }

            calculateRedDotProbability(personas) {
                if (!personas) return 0.5; // Default 50% if no personas
                
                let baseProbability = 0.5;
                
                // Adjust based on personality
                switch (personas.personality) {
                    case 'cautious':
                        baseProbability -= 0.15; // 35% chance of red
                        break;
                    case 'reckless':
                        baseProbability += 0.15; // 65% chance of red
                        break;
                    case 'optimistic':
                        baseProbability -= 0.05; // 45% chance of red
                        break;
                    case 'pessimistic':
                        baseProbability += 0.05; // 55% chance of red
                        break;
                }
                
                // Adjust based on playstyle
                switch (personas.playstyle) {
                    case 'lucky':
                        baseProbability -= 0.1; // More likely to get green
                        break;
                    case 'strategic':
                        baseProbability -= 0.05; // Slightly better odds
                        break;
                }
                
                // Clamp between 0.1 and 0.9
                return Math.max(0.1, Math.min(0.9, baseProbability));
            }

            animateOutcomeDotReveal(dot, isRed) {
                // First, flash between colors rapidly
                let flashCount = 0;
                const maxFlashes = 8;
                
                const flash = () => {
                    if (flashCount >= maxFlashes) {
                        // Final reveal - lock in the color
                        const finalColor = isRed ? '#ef4444' : '#22c55e';
                        dot.style.background = finalColor;
                        dot.style.boxShadow = `0 0 50px ${finalColor}`;
                        dot.style.transform = 'scale(1.2)';
                        
                        // Show result after brief pause
                        setTimeout(() => {
                            this.showTapRaceResult();
                        }, 800);
                        return;
                    }
                    
                    // Alternate between colors during flash
                    const color = flashCount % 2 === 0 ? '#22c55e' : '#ef4444';
                    dot.style.background = color;
                    dot.style.boxShadow = `0 0 40px ${color}`;
                    dot.style.transform = flashCount % 2 === 0 ? 'scale(1.1)' : 'scale(0.9)';
                    
                    flashCount++;
                    setTimeout(flash, 200);
                };
                
                flash();
            }

            showTapRaceResult() {
                const result = this.raceResult;
                const resultDiv = document.getElementById('raceResult');
                const continueBtn = document.getElementById('raceContinueButton');
                
                if (resultDiv) {
                    resultDiv.innerHTML = `<span style="color: ${result.color}; font-size: 1.1rem;">${result.message}</span>`;
                }
                
                // Apply points immediately
                if (window.gameInstance && window.gameInstance.gameState) {
                    window.gameInstance.gameState.strengthScore += result.points;
                    window.gameInstance.updateGameStats();
                    console.log(`‚öîÔ∏è Applied ${result.points} points, new score: ${window.gameInstance.gameState.strengthScore}`);
                }
                
                // Show continue button
                if (continueBtn) {
                    continueBtn.style.display = 'block';
                    continueBtn.focus();
                    continueBtn.onclick = () => {
                        this.completeTapRace();
                    };
                }
                
                // Create celebration or penalty animation
                setTimeout(() => {
                    if (result.isRed) {
                        this.createPhantomSuckAnimation();
                    } else {
                        this.createTapRaceWinAura(); // Add aura first
                        setTimeout(() => {
                            this.createCelebrationAnimation();
                        }, 100); // Small delay to show aura before confetti
                    }
                }, 500);
            }

            createTapRaceWinAura() {
                // Create large see-through aura for TAP race win
                const aura = document.createElement('div');
                
                // Get player position or use modal center
                const player = document.getElementById('playerPiece');
                let centerX, centerY;
                
                if (player) {
                    const playerRect = player.getBoundingClientRect();
                    centerX = playerRect.left + playerRect.width / 2;
                    centerY = playerRect.top + playerRect.height / 2;
                } else {
                    // Use screen center if player not visible
                    centerX = window.innerWidth / 2;
                    centerY = window.innerHeight / 2;
                }
                
                // Calculate size - 85% of screen width
                const size = window.innerWidth * 0.85;
                
                aura.style.cssText = `
                    position: fixed;
                    width: ${size}px;
                    height: ${size}px;
                    left: ${centerX - size/2}px;
                    top: ${centerY - size/2}px;
                    border-radius: 50%;
                    background: radial-gradient(circle, rgba(34, 197, 94, 0.3) 0%, rgba(34, 197, 94, 0.1) 50%, transparent 100%);
                    z-index: 1002;
                    pointer-events: none;
                    opacity: 0;
                    transform: scale(0.8);
                    transition: all 0.4s ease-in-out;
                `;
                
                document.body.appendChild(aura);
                
                // Start pulsing animation
                setTimeout(() => {
                    aura.style.opacity = '1';
                    aura.style.transform = 'scale(1)';
                }, 50);
                
                // Pulse 3 times over 1.2s
                let pulseCount = 0;
                const pulseInterval = setInterval(() => {
                    pulseCount++;
                    
                    // Scale up
                    aura.style.transform = 'scale(1.1)';
                    aura.style.opacity = '0.4';
                    
                    setTimeout(() => {
                        // Scale back down
                        aura.style.transform = 'scale(1)';
                        aura.style.opacity = '0.3';
                    }, 200);
                    
                    if (pulseCount >= 3) {
                        clearInterval(pulseInterval);
                        
                        // Fade out after 3 pulses
                        setTimeout(() => {
                            aura.style.opacity = '0';
                            aura.style.transform = 'scale(0.8)';
                            
                            setTimeout(() => {
                                if (aura.parentNode) {
                                    aura.parentNode.removeChild(aura);
                                }
                            }, 400);
                        }, 200);
                    }
                }, 400); // 400ms between pulses = 1.2s total for 3 pulses
            }

            createCelebrationAnimation() {
                // Create confetti burst
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        this.createConfettiPiece();
                    }, i * 50);
                }
            }

            createConfettiPiece() {
                const confetti = document.createElement('div');
                const colors = ['#22c55e', '#eab308', '#3b82f6', '#ec4899', '#f97316'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                confetti.innerHTML = 'üéâ';
                confetti.style.position = 'fixed';
                confetti.style.left = (window.innerWidth * Math.random()) + 'px';
                confetti.style.top = '0px';
                confetti.style.fontSize = '24px';
                confetti.style.color = color;
                confetti.style.zIndex = '9999';
                confetti.style.pointerEvents = 'none';
                confetti.style.transition = 'all 2s ease-in';
                
                document.body.appendChild(confetti);
                
                setTimeout(() => {
                    confetti.style.top = window.innerHeight + 'px';
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                    confetti.style.opacity = '0';
                }, 100);
                
                setTimeout(() => {
                    if (confetti.parentNode) {
                        confetti.parentNode.removeChild(confetti);
                    }
                }, 2100);
            }

            createPhantomSuckAnimation() {
                // Create swirling negative energy effect
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        this.createSuckParticle();
                    }, i * 100);
                }
            }

            createSuckParticle() {
                const particle = document.createElement('div');
                particle.innerHTML = 'üíÄ';
                particle.style.position = 'fixed';
                particle.style.left = (window.innerWidth * Math.random()) + 'px';
                particle.style.top = (window.innerHeight * Math.random()) + 'px';
                particle.style.fontSize = '20px';
                particle.style.zIndex = '9999';
                particle.style.pointerEvents = 'none';
                particle.style.transition = 'all 1.5s ease-in';
                particle.style.opacity = '0.8';
                
                document.body.appendChild(particle);
                
                // Animate toward center of screen
                setTimeout(() => {
                    particle.style.left = (window.innerWidth / 2) + 'px';
                    particle.style.top = (window.innerHeight / 2) + 'px';
                    particle.style.transform = 'scale(0.1)';
                    particle.style.opacity = '0';
                }, 100);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 1600);
            }

            completeTapRace() {
                // Restore default footer for future modals
                document.getElementById('defaultModalFooter').style.display = 'block';
                hideModal('squareModal');
                
                // Animate points above player token
                this.animatePointsAbovePlayer(this.raceResult.points, this.raceResult.color);
            }

            animatePointsAbovePlayer(points, color) {
                const player = document.getElementById('playerPiece');
                if (!player) {
                    // If no player found, just proceed with callback
                    setTimeout(() => {
                        if (this.pendingModalCallback) {
                            this.pendingModalCallback();
                        }
                    }, 1000);
                    return;
                }
                
                const playerRect = player.getBoundingClientRect();
                const centerX = playerRect.left + playerRect.width / 2;
                const centerY = playerRect.top + playerRect.height / 2;
                
                const pointsDisplay = document.createElement('div');
                pointsDisplay.innerHTML = `${points > 0 ? '+' : ''}${points}`;
                pointsDisplay.style.position = 'fixed';
                pointsDisplay.style.left = (centerX - 30) + 'px';
                pointsDisplay.style.top = (centerY - 60) + 'px';
                pointsDisplay.style.fontSize = '36px';
                pointsDisplay.style.fontWeight = 'bold';
                pointsDisplay.style.color = color;
                pointsDisplay.style.zIndex = '9999';
                pointsDisplay.style.pointerEvents = 'none';
                pointsDisplay.style.opacity = '0';
                pointsDisplay.style.transition = 'all 2s ease-out';
                pointsDisplay.style.textShadow = `0 0 10px ${color}`;
                
                document.body.appendChild(pointsDisplay);
                
                // Animate floating up
                setTimeout(() => {
                    pointsDisplay.style.opacity = '1';
                    pointsDisplay.style.top = (centerY - 120) + 'px';
                    pointsDisplay.style.transform = 'scale(1.2)';
                }, 100);
                
                // Fade out
                setTimeout(() => {
                    pointsDisplay.style.opacity = '0';
                    pointsDisplay.style.top = (centerY - 180) + 'px';
                }, 1500);
                
                // Remove and callback
                setTimeout(() => {
                    if (pointsDisplay.parentNode) {
                        pointsDisplay.parentNode.removeChild(pointsDisplay);
                    }
                    if (this.pendingModalCallback) {
                        this.pendingModalCallback();
                    }
                }, 2000);
            }

            showQuickAimModal(personas, callback = null) {
                console.log('üèπ ShowQuickAimModal called with personas:', personas);
                
                document.getElementById('modalTitle').textContent = 'üèπ Quick Aim Challenge';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem; height: 550px; position: relative; overflow: hidden;">
                        <div style="font-size: 1.2rem; margin-bottom: 1rem; font-weight: 600;">
                            Shoot 3 arrows at the moving target!
                        </div>
                        
                        <!-- Arrow Counter -->
                        <div id="arrowCounter" style="
                            position: absolute;
                            top: 20px;
                            right: 20px;
                            font-size: 1.2rem;
                            font-weight: bold;
                            color: var(--primary-color);
                            display: flex;
                            align-items: center;
                            gap: 0.5rem;
                        ">
                            <span>üèπ</span>
                            <span id="arrowCount">3/3</span>
                        </div>
                        
                        <!-- Target Area -->
                        <div id="targetArea" style="
                            position: relative;
                            width: 100%;
                            height: 300px;
                            margin: 2rem 0;
                            border: 2px solid var(--primary-color);
                            border-radius: 15px;
                            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
                            overflow: hidden;
                        ">
                            <!-- Moving Target -->
                            <div id="movingTarget" style="
                                position: absolute;
                                width: 120px;
                                height: 120px;
                                left: 50%;
                                top: 50%;
                                transform: translate(-50%, -50%);
                                transition: left 0.05s linear;
                            ">
                                <!-- Target Rings -->
                                <div style="
                                    position: relative;
                                    width: 100%;
                                    height: 100%;
                                    border-radius: 50%;
                                    background: conic-gradient(from 0deg, #ef4444, #f97316, #eab308, #22c55e, #3b82f6, #8b5cf6, #ec4899, #ef4444);
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                ">
                                    <!-- Outer Ring (1 point) -->
                                    <div class="target-ring" data-score="1" style="
                                        position: absolute;
                                        width: 100%;
                                        height: 100%;
                                        border-radius: 50%;
                                        background: #f97316;
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        font-size: 1.2rem;
                                        font-weight: bold;
                                        color: white;
                                        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                                    ">
                                        +1
                                        <!-- Ring 2 (3 points) -->
                                        <div class="target-ring" data-score="3" style="
                                            position: absolute;
                                            width: 75%;
                                            height: 75%;
                                            border-radius: 50%;
                                            background: #eab308;
                                            display: flex;
                                            align-items: center;
                                            justify-content: center;
                                            font-size: 1.1rem;
                                            font-weight: bold;
                                            color: white;
                                            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                                        ">
                                            +3
                                            <!-- Ring 3 (7 points) -->
                                            <div class="target-ring" data-score="7" style="
                                                position: absolute;
                                                width: 50%;
                                                height: 50%;
                                                border-radius: 50%;
                                                background: #22c55e;
                                                display: flex;
                                                align-items: center;
                                                justify-content: center;
                                                font-size: 1rem;
                                                font-weight: bold;
                                                color: white;
                                                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                                            ">
                                                +7
                                                <!-- Bullseye (15 points) -->
                                                <div class="target-ring" data-score="15" style="
                                                    position: absolute;
                                                    width: 30%;
                                                    height: 30%;
                                                    border-radius: 50%;
                                                    background: #dc2626;
                                                    box-shadow: 0 0 20px rgba(220, 38, 38, 0.6);
                                                    display: flex;
                                                    align-items: center;
                                                    justify-content: center;
                                                    font-size: 0.9rem;
                                                    font-weight: bold;
                                                    color: white;
                                                    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                                                ">+15</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Arrow Hit Markers Container -->
                            <div id="arrowHits" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
                        </div>
                        
                        <!-- Instructions -->
                        <div id="aimInstructions" style="
                            font-size: 1.1rem;
                            font-weight: 600;
                            color: var(--success-color);
                            margin-bottom: 1rem;
                        ">Press SPACEBAR to shoot!</div>
                        
                        <!-- Score Display -->
                        <div id="currentScore" style="
                            font-size: 1.5rem;
                            font-weight: bold;
                            color: var(--primary-color);
                            margin-bottom: 1rem;
                            min-height: 2rem;
                        ">Total Score: 0</div>
                        
                        <!-- Final Tally Display (initially hidden) -->
                        <div id="finalTally" style="
                            display: none;
                            background: rgba(255,255,255,0.9);
                            border: 2px solid var(--primary-color);
                            border-radius: 10px;
                            padding: 1rem;
                            margin: 1rem 0;
                        ">
                            <h3 style="margin: 0 0 1rem 0; color: var(--primary-color);">üéØ Final Results</h3>
                            <div id="tallyBreakdown" style="font-size: 1rem; line-height: 1.8;"></div>
                        </div>
                        
                        <!-- Continue Button (initially hidden) -->
                        <button id="aimContinueButton" style="
                            display: none;
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 2rem;
                            border-radius: 8px;
                            font-size: 1.1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                            font-family: 'Space Grotesk', sans-serif;
                            margin-top: 1rem;
                        " onmouseover="this.style.background='var(--secondary-color)'" 
                           onmouseout="this.style.background='var(--primary-color)'">
                            Continue
                        </button>
                    </div>
                `;
                
                // Store callback and game state
                this.pendingModalCallback = callback;
                this.aimPersonas = personas;
                this.arrowsRemaining = 3;
                this.arrowHits = [];
                this.targetDirection = 1; // 1 for right, -1 for left
                this.targetSpeed = 1.5; // Slower for better playability
                this.gameActive = true;
                this.totalScore = 0;
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Setup controls and start target movement
                setTimeout(() => {
                    this.setupAimControls();
                    this.startTargetMovement();
                }, 100);
            }

            setupAimControls() {
                // Add keydown listener for spacebar shooting
                this.aimKeyHandler = (e) => {
                    if (e.code === 'Space' && this.gameActive && this.arrowsRemaining > 0) {
                        e.preventDefault();
                        this.shootArrow();
                    }
                };
                
                document.addEventListener('keydown', this.aimKeyHandler);
                
                // Focus the modal to ensure key events are captured
                const modal = document.getElementById('squareModal');
                if (modal) {
                    modal.focus();
                    modal.setAttribute('tabindex', '-1');
                }
            }

            startTargetMovement() {
                const target = document.getElementById('movingTarget');
                const targetArea = document.getElementById('targetArea');
                
                if (!target || !targetArea) return;
                
                const moveTarget = () => {
                    if (!this.gameActive) return;
                    
                    const areaWidth = targetArea.offsetWidth;
                    const targetWidth = 120; // Target width
                    const maxLeft = areaWidth - targetWidth;
                    
                    // Get current position
                    const currentLeft = parseInt(target.style.left) || (areaWidth / 2 - targetWidth / 2);
                    
                    // Calculate new position
                    let newLeft = currentLeft + (this.targetSpeed * this.targetDirection);
                    
                    // Bounce off walls with consistent speed
                    if (newLeft <= 0) {
                        newLeft = 0;
                        this.targetDirection = 1;
                        this.targetSpeed = 1.8; // Consistent moderate speed
                    } else if (newLeft >= maxLeft) {
                        newLeft = maxLeft;
                        this.targetDirection = -1;
                        this.targetSpeed = 1.8; // Consistent moderate speed
                    }
                    
                    target.style.left = newLeft + 'px';
                    
                    if (this.gameActive) {
                        requestAnimationFrame(moveTarget);
                    }
                };
                
                requestAnimationFrame(moveTarget);
            }

            shootArrow() {
                if (!this.gameActive || this.arrowsRemaining <= 0) return;
                
                this.arrowsRemaining--;
                this.updateArrowCounter();
                
                // Get target position
                const target = document.getElementById('movingTarget');
                const targetArea = document.getElementById('targetArea');
                
                if (!target || !targetArea) return;
                
                // Calculate hit position
                const targetRect = target.getBoundingClientRect();
                const areaRect = targetArea.getBoundingClientRect();
                const targetCenterX = targetRect.left + targetRect.width / 2;
                const targetCenterY = targetRect.top + targetRect.height / 2;
                
                // Calculate relative position within target area
                const relativeX = targetCenterX - areaRect.left;
                const relativeY = targetCenterY - areaRect.top;
                
                // Determine which ring was hit
                const targetCenter = { x: 60, y: 60 }; // Center of 120px target
                const hitX = relativeX - (parseInt(target.style.left) || 0);
                const hitY = relativeY - 150; // Adjust for target center
                
                const distanceFromCenter = Math.sqrt(
                    Math.pow(hitX - targetCenter.x, 2) + 
                    Math.pow(hitY - targetCenter.y, 2)
                );
                
                // Determine score based on distance from center - more generous zones
                let score, hitZone, color;
                const radius = 60; // Half of target size
                
                if (distanceFromCenter <= radius * 0.15) { // Bullseye (30% of radius - larger for easier hitting)
                    score = 15;
                    hitZone = 'Bullseye!';
                    color = '#dc2626';
                } else if (distanceFromCenter <= radius * 0.35) { // Inner ring (50% of radius)
                    score = 7;
                    hitZone = 'Inner Ring (+7)';
                    color = '#22c55e';
                } else if (distanceFromCenter <= radius * 0.55) { // Middle ring (75% of radius)
                    score = 3;
                    hitZone = 'Middle Ring (+3)';
                    color = '#eab308';
                } else if (distanceFromCenter <= radius * 0.7) { // Outer ring (100% of radius - extended)
                    score = 1;
                    hitZone = 'Outer Ring (+1)';
                    color = '#f97316';
                } else { // Missed target completely
                    score = 0;
                    hitZone = 'Near Miss';
                    color = '#6b7280';
                }
                
                // Store the hit
                const hit = {
                    arrow: 4 - this.arrowsRemaining, // Arrow number (1, 2, 3)
                    score: score,
                    zone: hitZone,
                    color: color,
                    x: relativeX,
                    y: relativeY
                };
                
                this.arrowHits.push(hit);
                this.totalScore += score;
                
                // Visual feedback - show arrow and score
                this.showArrowHit(hit);
                
                // Update score display
                this.updateScoreDisplay();
                
                // Check if game is over
                if (this.arrowsRemaining <= 0) {
                    setTimeout(() => {
                        this.endAimGame();
                    }, 1000);
                }
                
                console.log(`üèπ Arrow ${hit.arrow}: ${hitZone} = ${score} points (Total: ${this.totalScore})`);
            }

            showArrowHit(hit) {
                const arrowHits = document.getElementById('arrowHits');
                if (!arrowHits) return;
                
                // Create arrow marker
                const arrow = document.createElement('div');
                arrow.innerHTML = 'üèπ';
                arrow.style.position = 'absolute';
                arrow.style.left = (hit.x - 10) + 'px';
                arrow.style.top = (hit.y - 10) + 'px';
                arrow.style.fontSize = '20px';
                arrow.style.zIndex = '10';
                arrow.style.pointerEvents = 'none';
                arrow.style.transform = 'rotate(45deg)';
                
                arrowHits.appendChild(arrow);
                
                // Create score popup
                const scorePopup = document.createElement('div');
                scorePopup.innerHTML = `${hit.score > 0 ? '+' : ''}${hit.score}`;
                scorePopup.style.position = 'absolute';
                scorePopup.style.left = (hit.x - 15) + 'px';
                scorePopup.style.top = (hit.y - 40) + 'px';
                scorePopup.style.fontSize = '24px';
                scorePopup.style.fontWeight = 'bold';
                scorePopup.style.color = hit.color;
                scorePopup.style.textShadow = `0 0 10px ${hit.color}`;
                scorePopup.style.zIndex = '11';
                scorePopup.style.pointerEvents = 'none';
                scorePopup.style.opacity = '0';
                scorePopup.style.transition = 'all 1s ease-out';
                
                arrowHits.appendChild(scorePopup);
                
                // Animate score popup
                setTimeout(() => {
                    scorePopup.style.opacity = '1';
                    scorePopup.style.top = (hit.y - 60) + 'px';
                    scorePopup.style.transform = 'scale(1.2)';
                }, 100);
                
                // Fade out score popup
                setTimeout(() => {
                    scorePopup.style.opacity = '0';
                }, 1500);
                
                // Bullseye special effect
                if (hit.zone === 'Bullseye!') {
                    this.createBullseyeEffect(hit.x, hit.y);
                }
            }

            createBullseyeEffect(x, y) {
                const arrowHits = document.getElementById('arrowHits');
                if (!arrowHits) return;
                
                // Create glowing rings effect
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const ring = document.createElement('div');
                        ring.style.position = 'absolute';
                        ring.style.left = (x - 30) + 'px';
                        ring.style.top = (y - 30) + 'px';
                        ring.style.width = '60px';
                        ring.style.height = '60px';
                        ring.style.border = '3px solid #22c55e';
                        ring.style.borderRadius = '50%';
                        ring.style.opacity = '1';
                        ring.style.transform = 'scale(0.5)';
                        ring.style.transition = 'all 1s ease-out';
                        ring.style.pointerEvents = 'none';
                        ring.style.boxShadow = '0 0 20px #22c55e';
                        
                        arrowHits.appendChild(ring);
                        
                        setTimeout(() => {
                            ring.style.transform = 'scale(2)';
                            ring.style.opacity = '0';
                        }, 100);
                        
                        setTimeout(() => {
                            if (ring.parentNode) {
                                ring.parentNode.removeChild(ring);
                            }
                        }, 1100);
                    }, i * 200);
                }
            }

            updateArrowCounter() {
                const arrowCount = document.getElementById('arrowCount');
                if (arrowCount) {
                    arrowCount.textContent = `${this.arrowsRemaining}/3`;
                }
            }

            updateScoreDisplay() {
                const currentScore = document.getElementById('currentScore');
                if (currentScore) {
                    const color = this.totalScore >= 0 ? '#22c55e' : '#ef4444';
                    currentScore.innerHTML = `Total Score: <span style="color: ${color}; font-size: 1.8rem;">${this.totalScore}</span>`;
                }
            }

            endAimGame() {
                this.gameActive = false;
                
                // Remove keydown listener
                if (this.aimKeyHandler) {
                    document.removeEventListener('keydown', this.aimKeyHandler);
                }
                
                // Hide instructions
                const instructions = document.getElementById('aimInstructions');
                if (instructions) {
                    instructions.textContent = 'Game Complete!';
                    instructions.style.color = '#6b7280';
                }
                
                // Show final tally
                this.showFinalTally();
            }

            showFinalTally() {
                const finalTally = document.getElementById('finalTally');
                const tallyBreakdown = document.getElementById('tallyBreakdown');
                
                if (!finalTally || !tallyBreakdown) return;
                
                let breakdown = '';
                this.arrowHits.forEach((hit, index) => {
                    const color = hit.color;
                    breakdown += `<div style="display: flex; justify-content: space-between; align-items: center; padding: 0.25rem 0;">
                        <span><strong>Arrow ${hit.arrow}:</strong> ${hit.zone}</span>
                        <span style="color: ${color}; font-weight: bold; font-size: 1.2rem;">${hit.score > 0 ? '+' : ''}${hit.score}</span>
                    </div>`;
                });
                
                const finalColor = this.totalScore >= 0 ? '#22c55e' : '#ef4444';
                breakdown += `<div style="border-top: 2px solid var(--primary-color); margin-top: 0.5rem; padding-top: 0.5rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 1.3rem;">
                        <span style="font-weight: bold;">Final Total:</span>
                        <span style="color: ${finalColor}; font-weight: bold; font-size: 1.5rem;">${this.totalScore > 0 ? '+' : ''}${this.totalScore}</span>
                    </div>
                </div>`;
                
                tallyBreakdown.innerHTML = breakdown;
                finalTally.style.display = 'block';
                
                // Apply points immediately
                if (window.gameInstance && window.gameInstance.gameState) {
                    window.gameInstance.gameState.strengthScore += this.totalScore;
                    window.gameInstance.updateGameStats();
                    console.log(`üèπ Applied ${this.totalScore} points, new score: ${window.gameInstance.gameState.strengthScore}`);
                }
                
                // Show continue button
                const continueBtn = document.getElementById('aimContinueButton');
                if (continueBtn) {
                    continueBtn.style.display = 'block';
                    continueBtn.focus();
                    continueBtn.onclick = () => {
                        this.completeAimGame();
                    };
                }
            }

            completeAimGame() {
                // Restore default footer for future modals
                document.getElementById('defaultModalFooter').style.display = 'block';
                hideModal('squareModal');
                
                // Animate points above player token
                const color = this.totalScore >= 0 ? '#22c55e' : '#ef4444';
                this.animateArrowPointsToPlayer(this.totalScore, color);
            }

            animateArrowPointsToPlayer(points, color) {
                const player = document.getElementById('playerPiece');
                if (!player) {
                    // If no player found, just proceed with callback
                    setTimeout(() => {
                        if (this.pendingModalCallback) {
                            this.pendingModalCallback();
                        }
                    }, 1000);
                    return;
                }
                
                const playerRect = player.getBoundingClientRect();
                const centerX = playerRect.left + playerRect.width / 2;
                const centerY = playerRect.top + playerRect.height / 2;
                
                // Create multiple arrow effects flying to player
                for (let i = 0; i < this.arrowHits.length; i++) {
                    setTimeout(() => {
                        const arrow = document.createElement('div');
                        arrow.innerHTML = 'üèπ';
                        arrow.style.position = 'fixed';
                        arrow.style.left = (centerX + (i - 1) * 40) + 'px';
                        arrow.style.top = (centerY - 100) + 'px';
                        arrow.style.fontSize = '24px';
                        arrow.style.zIndex = '9999';
                        arrow.style.pointerEvents = 'none';
                        arrow.style.opacity = '0';
                        arrow.style.transition = 'all 1.5s ease-out';
                        arrow.style.transform = 'rotate(90deg)';
                        
                        document.body.appendChild(arrow);
                        
                        // Animate arrow flying to player
                        setTimeout(() => {
                            arrow.style.opacity = '1';
                            arrow.style.top = (centerY - 20) + 'px';
                            arrow.style.transform = 'rotate(90deg) scale(0.5)';
                        }, 100);
                        
                        // Fade out arrow
                        setTimeout(() => {
                            arrow.style.opacity = '0';
                        }, 1200);
                        
                        // Remove arrow
                        setTimeout(() => {
                            if (arrow.parentNode) {
                                arrow.parentNode.removeChild(arrow);
                            }
                        }, 1700);
                    }, i * 300);
                }
                
                // Show final points display
                setTimeout(() => {
                    const pointsDisplay = document.createElement('div');
                    pointsDisplay.innerHTML = `${points > 0 ? '+' : ''}${points}`;
                    pointsDisplay.style.position = 'fixed';
                    pointsDisplay.style.left = (centerX - 30) + 'px';
                    pointsDisplay.style.top = (centerY - 60) + 'px';
                    pointsDisplay.style.fontSize = '36px';
                    pointsDisplay.style.fontWeight = 'bold';
                    pointsDisplay.style.color = color;
                    pointsDisplay.style.zIndex = '9999';
                    pointsDisplay.style.pointerEvents = 'none';
                    pointsDisplay.style.opacity = '0';
                    pointsDisplay.style.transition = 'all 2s ease-out';
                    pointsDisplay.style.textShadow = `0 0 10px ${color}`;
                    
                    document.body.appendChild(pointsDisplay);
                    
                    // Animate points floating up
                    setTimeout(() => {
                        pointsDisplay.style.opacity = '1';
                        pointsDisplay.style.top = (centerY - 120) + 'px';
                        pointsDisplay.style.transform = 'scale(1.2)';
                    }, 100);
                    
                    // Fade out
                    setTimeout(() => {
                        pointsDisplay.style.opacity = '0';
                        pointsDisplay.style.top = (centerY - 180) + 'px';
                    }, 1500);
                    
                    // Remove and callback
                    setTimeout(() => {
                        if (pointsDisplay.parentNode) {
                            pointsDisplay.parentNode.removeChild(pointsDisplay);
                        }
                        if (this.pendingModalCallback) {
                            this.pendingModalCallback();
                        }
                    }, 2000);
                }, this.arrowHits.length * 300 + 500);
            }

            showMemoryMatchModal(personas, callback = null) {
                console.log('üß† ShowMemoryMatchModal called with personas:', personas);
                
                document.getElementById('modalTitle').textContent = 'üß† Memory Match Challenge';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem; height: 600px; position: relative;">
                        <div style="font-size: 1.2rem; margin-bottom: 1rem; font-weight: 600;">
                            Test your memory with persona-themed cards!
                        </div>
                        
                        <!-- Timer Display -->
                        <div id="memoryTimer" style="
                            font-size: 2rem;
                            font-weight: bold;
                            color: var(--primary-color);
                            margin-bottom: 1rem;
                            min-height: 3rem;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">
                            <span id="timerText">Memorize: 5</span>
                        </div>
                        
                        <!-- Phase Instructions -->
                        <div id="phaseInstructions" style="
                            font-size: 1.1rem;
                            font-weight: 600;
                            color: var(--success-color);
                            margin-bottom: 1.5rem;
                            min-height: 2rem;
                        ">Study the cards - memorization phase!</div>
                        
                        <!-- Game Grid -->
                        <div id="memoryGrid" style="
                            display: grid;
                            grid-template-columns: repeat(4, 1fr);
                            gap: 0.5rem;
                            max-width: 400px;
                            margin: 0 auto 2rem auto;
                            aspect-ratio: 1;
                        ">
                            <!-- Cards will be generated here -->
                        </div>
                        
                        <!-- Score Display -->
                        <div id="memoryScore" style="
                            font-size: 1.3rem;
                            font-weight: bold;
                            margin-bottom: 1rem;
                            min-height: 2rem;
                            display: none;
                        ">Score: 0</div>
                        
                        <!-- Final Results (initially hidden) -->
                        <div id="memoryResults" style="
                            display: none;
                            background: rgba(255,255,255,0.95);
                            border: 2px solid var(--primary-color);
                            border-radius: 10px;
                            padding: 1.5rem;
                            margin: 1rem 0;
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            width: 80%;
                            z-index: 20;
                        ">
                            <h3 style="margin: 0 0 1rem 0; color: var(--primary-color);">üéØ Memory Challenge Complete!</h3>
                            <div id="finalTime" style="font-size: 1.4rem; margin-bottom: 1rem; font-weight: bold;"></div>
                            <div id="finalScore" style="font-size: 1.6rem; margin-bottom: 1.5rem; font-weight: bold;"></div>
                            <button id="memoryContinueButton" style="
                                background: var(--primary-color);
                                color: white;
                                border: none;
                                padding: 0.75rem 2rem;
                                border-radius: 8px;
                                font-size: 1.1rem;
                                font-weight: 600;
                                cursor: pointer;
                                transition: background 0.3s ease;
                                font-family: 'Space Grotesk', sans-serif;
                            " onmouseover="this.style.background='var(--secondary-color)'" 
                               onmouseout="this.style.background='var(--primary-color)'">
                                Continue
                            </button>
                        </div>
                    </div>
                `;
                
                // Store callback and game state
                this.pendingModalCallback = callback;
                this.memoryPersonas = personas;
                this.memoryPhase = 'memorize'; // 'memorize', 'play', 'complete'
                this.memoryStartTime = null;
                this.memoryCards = [];
                this.flippedCards = [];
                this.matchedPairs = 0;
                this.memoryScore = 0;
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Generate cards and start memorization phase
                setTimeout(() => {
                    this.generateMemoryCards();
                    this.startMemorizationPhase();
                }, 100);
            }

            generateMemoryCards() {
                const personas = this.memoryPersonas;
                const grid = document.getElementById('memoryGrid');
                
                if (!grid) return;
                
                // Generate persona-themed icon pairs using PNG assets
                const iconSets = {
                    cautious: [
                        '<img src="Assets/crown.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üõ°Ô∏è\'">',
                        '<img src="Assets/wand.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üîí\'">',
                        '<img src="Assets/heart.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üè∞\'">',
                        '<img src="Assets/flower.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'‚öì\'">',
                        '<img src="Assets/cookie.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üóùÔ∏è\'">',
                        '<img src="Assets/butterfly.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üß±\'">',
                        '<img src="Assets/lightning.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üîê\'">',
                        '<img src="Assets/rainbow.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üèõÔ∏è\'">'
                    ],
                    reckless: [
                        '<img src="Assets/lightning.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üî•\'">',
                        '<img src="Assets/crown.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'‚ö°\'">',
                        '<img src="Assets/wand.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üí•\'">',
                        '<img src="Assets/rainbow.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üå™Ô∏è\'">',
                        '<img src="Assets/heart.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üéØ\'">',
                        '<img src="Assets/flower.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'‚öîÔ∏è\'">',
                        '<img src="Assets/butterfly.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üèÉ\'">',
                        '<img src="Assets/cookie.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üöÄ\'">'
                    ],
                    optimistic: [
                        '<img src="Assets/rainbow.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'‚òÄÔ∏è\'">',
                        '<img src="Assets/butterfly.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üåü\'">',
                        '<img src="Assets/flower.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üåà\'">',
                        '<img src="Assets/heart.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'ü¶ã\'">',
                        '<img src="Assets/crown.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üå∏\'">',
                        '<img src="Assets/wand.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üíé\'">',
                        '<img src="Assets/lightning.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'‚ú®\'">',
                        '<img src="Assets/cookie.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üéä\'">'
                    ],
                    pessimistic: [
                        '<img src="Assets/wand.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üåô\'">',
                        '<img src="Assets/lightning.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'‚õàÔ∏è\'">',
                        '<img src="Assets/crown.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üîÆ\'">',
                        '<img src="Assets/heart.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üïØÔ∏è\'">',
                        '<img src="Assets/flower.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üóùÔ∏è\'">',
                        '<img src="Assets/butterfly.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'‚ö°\'">',
                        '<img src="Assets/rainbow.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üåä\'">',
                        '<img src="Assets/cookie.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üî±\'">'
                    ],
                    default: [
                        '<img src="Assets/butterfly.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üí´\'">',
                        '<img src="Assets/cookie.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üî•\'">',
                        '<img src="Assets/crown.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üíé\'">',
                        '<img src="Assets/flower.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üåü\'">',
                        '<img src="Assets/heart.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'‚ö°\'">',
                        '<img src="Assets/lightning.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'üåà\'">',
                        '<img src="Assets/rainbow.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'ü¶ã\'">',
                        '<img src="Assets/wand.png" style="width: 40px; height: 40px; object-fit: contain;" onerror="this.outerHTML=\'‚ú®\'">'
                    ]
                };
                
                const icons = iconSets[personas?.personality] || iconSets.default;
                
                // Create 8 pairs (16 cards total) using the first 8 icons
                const cardData = [];
                for (let i = 0; i < 8; i++) {
                    const icon = icons[i];
                    cardData.push({ id: i * 2, icon: icon, matched: false });
                    cardData.push({ id: i * 2 + 1, icon: icon, matched: false });
                }
                
                // Shuffle the cards
                for (let i = cardData.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [cardData[i], cardData[j]] = [cardData[j], cardData[i]];
                }
                
                this.memoryCards = cardData;
                
                // Generate HTML for cards
                grid.innerHTML = '';
                cardData.forEach((card, index) => {
                    const cardElement = this.createMemoryCard(card, index);
                    grid.appendChild(cardElement);
                });
            }

            createMemoryCard(cardData, index) {
                const card = document.createElement('div');
                card.className = 'memory-card';
                card.dataset.cardIndex = index;
                card.style.cssText = `
                    position: relative;
                    aspect-ratio: 1;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: transform 0.25s ease;
                    transform-style: preserve-3d;
                    user-select: none;
                `;
                
                // Card back
                const cardBack = document.createElement('div');
                cardBack.className = 'card-back';
                cardBack.style.cssText = `
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
                    border: 2px solid #ffffff;
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.5rem;
                    color: white;
                    backface-visibility: hidden;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                `;
                cardBack.textContent = '?';
                
                // Card front
                const cardFront = document.createElement('div');
                cardFront.className = 'card-front';
                cardFront.style.cssText = `
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, #ffffff, #f8fafc);
                    border: 2px solid var(--primary-color);
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 2.5rem;
                    backface-visibility: hidden;
                    transform: rotateY(180deg);
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                `;
                cardFront.innerHTML = cardData.icon;
                
                card.appendChild(cardBack);
                card.appendChild(cardFront);
                
                // Add click handler for gameplay phase
                card.onclick = () => {
                    if (this.memoryPhase === 'play' && !cardData.matched && this.flippedCards.length < 2) {
                        this.flipCard(index);
                    }
                };
                
                return card;
            }

            startMemorizationPhase() {
                console.log('üß† Starting memorization phase');
                this.memoryPhase = 'memorize';
                
                // Flip all cards face up immediately
                const cards = document.querySelectorAll('.memory-card');
                cards.forEach(card => {
                    card.style.transform = 'rotateY(180deg)';
                });
                
                // Start 5-second countdown
                let timeLeft = 5;
                const timerText = document.getElementById('timerText');
                const instructions = document.getElementById('phaseInstructions');
                
                const countdown = setInterval(() => {
                    if (timerText) {
                        timerText.textContent = `Memorize: ${timeLeft}`;
                    }
                    
                    timeLeft--;
                    
                    if (timeLeft < 0) {
                        clearInterval(countdown);
                        this.startGameplayPhase();
                    }
                }, 1000);
            }

            startGameplayPhase() {
                console.log('üß† Starting gameplay phase');
                this.memoryPhase = 'play';
                this.memoryStartTime = Date.now();
                
                // Flip all cards face down
                const cards = document.querySelectorAll('.memory-card');
                cards.forEach(card => {
                    card.style.transform = 'rotateY(0deg)';
                });
                
                // Update UI
                const timerText = document.getElementById('timerText');
                const instructions = document.getElementById('phaseInstructions');
                const scoreDisplay = document.getElementById('memoryScore');
                
                if (instructions) {
                    instructions.textContent = 'Find the matching pairs!';
                }
                
                if (scoreDisplay) {
                    scoreDisplay.style.display = 'block';
                }
                
                // Start gameplay timer
                this.updateGameTimer();
            }

            updateGameTimer() {
                if (this.memoryPhase !== 'play') return;
                
                const elapsed = (Date.now() - this.memoryStartTime) / 1000;
                const timerText = document.getElementById('timerText');
                
                if (timerText) {
                    timerText.textContent = `Time: ${elapsed.toFixed(1)}s`;
                }
                
                // Continue updating
                if (this.memoryPhase === 'play') {
                    setTimeout(() => this.updateGameTimer(), 100);
                }
            }

            flipCard(cardIndex) {
                if (this.flippedCards.length >= 2 || this.memoryCards[cardIndex].matched) return;
                
                const card = document.querySelector(`[data-card-index="${cardIndex}"]`);
                if (!card) return;
                
                // Flip the card
                card.style.transform = 'rotateY(180deg)';
                this.flippedCards.push(cardIndex);
                
                // Check for match when 2 cards are flipped
                if (this.flippedCards.length === 2) {
                    setTimeout(() => {
                        this.checkForMatch();
                    }, 500); // 0.5 second delay to show both cards
                }
            }

            checkForMatch() {
                const [index1, index2] = this.flippedCards;
                const card1 = this.memoryCards[index1];
                const card2 = this.memoryCards[index2];
                
                if (card1.icon === card2.icon) {
                    // Match found!
                    console.log('üéØ Match found:', card1.icon);
                    this.handleMatch(index1, index2);
                } else {
                    // No match - flip cards back
                    console.log('‚ùå No match');
                    this.handleNoMatch(index1, index2);
                }
                
                this.flippedCards = [];
            }

            handleMatch(index1, index2) {
                this.memoryCards[index1].matched = true;
                this.memoryCards[index2].matched = true;
                this.matchedPairs++;
                
                // Create sparkle animation and remove cards
                const card1 = document.querySelector(`[data-card-index="${index1}"]`);
                const card2 = document.querySelector(`[data-card-index="${index2}"]`);
                
                [card1, card2].forEach(card => {
                    if (card) {
                        this.createSparkleEffect(card);
                        
                        // Vanish animation
                        setTimeout(() => {
                            card.style.transition = 'all 0.4s ease-out';
                            card.style.transform = 'rotateY(180deg) scale(0)';
                            card.style.opacity = '0';
                        }, 200);
                    }
                });
                
                // Check if game is complete
                if (this.matchedPairs === 8) {
                    setTimeout(() => {
                        this.completeMemoryGame();
                    }, 600);
                }
            }

            handleNoMatch(index1, index2) {
                // Flip cards back after delay
                setTimeout(() => {
                    const card1 = document.querySelector(`[data-card-index="${index1}"]`);
                    const card2 = document.querySelector(`[data-card-index="${index2}"]`);
                    
                    [card1, card2].forEach(card => {
                        if (card) {
                            card.style.transform = 'rotateY(0deg)';
                        }
                    });
                }, 500);
            }

            createSparkleEffect(cardElement) {
                const rect = cardElement.getBoundingClientRect();
                const container = cardElement.parentElement;
                
                // Create multiple sparkles
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        const sparkle = document.createElement('div');
                        sparkle.innerHTML = '<img src="Assets/star.png" style="width: 16px; height: 16px; object-fit: contain;" onerror="this.outerHTML=\'‚ú®\'">';
                        sparkle.style.position = 'absolute';
                        sparkle.style.left = (rect.width * Math.random()) + 'px';
                        sparkle.style.top = (rect.height * Math.random()) + 'px';
                        sparkle.style.fontSize = '16px';
                        sparkle.style.pointerEvents = 'none';
                        sparkle.style.zIndex = '15';
                        sparkle.style.opacity = '1';
                        sparkle.style.transition = 'all 1s ease-out';
                        
                        cardElement.appendChild(sparkle);
                        
                        // Animate sparkle
                        setTimeout(() => {
                            sparkle.style.transform = `translate(${(Math.random() - 0.5) * 100}px, ${(Math.random() - 0.5) * 100}px) scale(0)`;
                            sparkle.style.opacity = '0';
                        }, 100);
                        
                        // Remove sparkle
                        setTimeout(() => {
                            if (sparkle.parentNode) {
                                sparkle.parentNode.removeChild(sparkle);
                            }
                        }, 1100);
                    }, i * 50);
                }
            }

            completeMemoryGame() {
                this.memoryPhase = 'complete';
                const finalTime = (Date.now() - this.memoryStartTime) / 1000;
                
                // Calculate score based on time
                let score = 0;
                let message = '';
                
                if (finalTime <= 35) {
                    score = 20;
                    message = 'Good memory! Completed within time limit!';
                } else {
                    score = -20;
                    message = 'Too slow! Practice makes perfect.';
                }
                
                console.log(`üß† Memory game complete in ${finalTime.toFixed(1)}s, score: ${score}`);
                
                // Apply points immediately
                if (window.gameInstance && window.gameInstance.gameState) {
                    window.gameInstance.gameState.strengthScore += score;
                    window.gameInstance.updateGameStats();
                }
                
                // Show results
                this.showMemoryResults(finalTime, score, message);
            }

            showMemoryResults(time, score, message) {
                const results = document.getElementById('memoryResults');
                const finalTime = document.getElementById('finalTime');
                const finalScore = document.getElementById('finalScore');
                const continueBtn = document.getElementById('memoryContinueButton');
                
                if (finalTime) {
                    finalTime.innerHTML = `Your Time: <span style="color: var(--primary-color);">${time.toFixed(1)}s</span>`;
                }
                
                if (finalScore) {
                    const color = score > 0 ? '#22c55e' : '#ef4444';
                    finalScore.innerHTML = `
                        <div style="margin-bottom: 0.5rem;">${message}</div>
                        <div style="color: ${color}; font-size: 2rem;">
                            ${score > 0 ? '+' : ''}${score} Points
                        </div>
                    `;
                }
                
                if (results) {
                    results.style.display = 'block';
                }
                
                if (continueBtn) {
                    continueBtn.focus();
                    continueBtn.onclick = () => {
                        this.completeMemoryMatch();
                    };
                }
                
                // Create celebration animation
                setTimeout(() => {
                    if (score > 0) {
                        this.createMemoryCelebration();
                    }
                }, 500);
            }

            createMemoryCelebration() {
                // Create card scatter effect
                const grid = document.getElementById('memoryGrid');
                if (!grid) return;
                
                for (let i = 0; i < 16; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.innerHTML = 'üéØ';
                        particle.style.position = 'fixed';
                        particle.style.left = (window.innerWidth * Math.random()) + 'px';
                        particle.style.top = '0px';
                        particle.style.fontSize = '20px';
                        particle.style.zIndex = '9999';
                        particle.style.pointerEvents = 'none';
                        particle.style.transition = 'all 2s ease-in';
                        
                        document.body.appendChild(particle);
                        
                        setTimeout(() => {
                            particle.style.top = window.innerHeight + 'px';
                            particle.style.transform = `rotate(${Math.random() * 360}deg)`;
                            particle.style.opacity = '0';
                        }, 100);
                        
                        setTimeout(() => {
                            if (particle.parentNode) {
                                particle.parentNode.removeChild(particle);
                            }
                        }, 2100);
                    }, i * 100);
                }
            }

            completeMemoryMatch() {
                // Restore default footer for future modals
                document.getElementById('defaultModalFooter').style.display = 'block';
                hideModal('squareModal');
                
                // Proceed with callback after brief delay
                setTimeout(() => {
                    if (this.pendingModalCallback) {
                        this.pendingModalCallback();
                    }
                }, 500);
            }

            // ========== COLLECT STAR MODAL ==========
            showDodgeStarModal(personas, callback = null) {
                console.log('‚≠ê ShowDodgeStarModal called with personas:', personas);
                
                document.getElementById('modalTitle').textContent = '‚≠ê Collect Star Challenge';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem; height: 650px; position: relative; overflow: hidden;">
                        <div style="font-size: 1.1rem; margin-bottom: 1rem;">
                            Collect falling stars (‚≠ê) and power-up shields (üõ°Ô∏è)!<br>
                            Use WASD or Arrow Keys to move your character.<br>
                            <span style="color: #22c55e; font-weight: bold;">Each Star = +2 points</span> | 
                            <span style="color: #3b82f6; font-weight: bold;">Each Shield = +5 points</span>
                        </div>
                        
                        <div id="dodgeStarArena" style="
                            width: 500px;
                            height: 400px;
                            background: linear-gradient(45deg, #1e3a8a, #1e40af);
                            border: 3px solid #3b82f6;
                            border-radius: 12px;
                            position: relative;
                            margin: 0 auto 1rem auto;
                            overflow: hidden;
                        ">
                            <!-- Player character in center -->
                            <div id="dodgePlayer" style="
                                position: absolute;
                                left: 235px;
                                top: 185px;
                                width: 30px;
                                height: 30px;
                                background: #fbbf24;
                                border-radius: 50%;
                                border: 2px solid #f59e0b;
                                z-index: 100;
                                transition: all 0.1s ease;
                            ">üèÉ</div>
                            
                            <!-- Shield spawns on edges -->
                            <div id="dodgeShields" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                            
                            <!-- Stars fall from top -->
                            <div id="dodgeStars" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                        </div>
                        
                        <div style="display: flex; justify-content: space-around; margin-bottom: 1rem;">
                            <div>Stars Collected: <span id="starsCollected" style="color: #22c55e; font-weight: bold;">0</span></div>
                            <div>Shields Collected: <span id="shieldsCollected" style="color: #3b82f6; font-weight: bold;">0</span></div>
                            <div>Total Score: <span id="totalStarScore" style="color: #fbbf24; font-weight: bold;">0</span></div>
                        </div>
                        
                        <button id="dodgeStartBtn" style="
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                        " onmouseover="this.style.background='var(--secondary-color)'" 
                           onmouseout="this.style.background='var(--primary-color)'">
                            Start Collection Challenge!
                        </button>
                        
                        <div id="dodgeResults" style="
                            font-size: 1.2rem;
                            margin-top: 1rem;
                            font-weight: bold;
                            min-height: 2rem;
                        "></div>
                    </div>
                `;
                
                // Store callback and initialize game
                this.pendingModalCallback = callback;
                this.dodgeStarGameActive = false;
                this.dodgeStarData = {
                    starsCollected: 0,
                    shieldsCollected: 0,
                    totalScore: 0,
                    playerX: 235,
                    playerY: 185,
                    stars: [],
                    shields: [],
                    gameTime: 0,
                    maxGameTime: 30000, // 30 seconds
                    personas: personas
                };
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Setup game start
                setTimeout(() => {
                    const startBtn = document.getElementById('dodgeStartBtn');
                    if (startBtn) {
                        startBtn.onclick = () => {
                            this.startDodgeStarGame();
                        };
                    }
                }, 100);
            }
            
            startDodgeStarGame() {
                console.log('‚≠ê Starting Collect Star mini-game');
                this.dodgeStarGameActive = true;
                
                // Hide start button
                document.getElementById('dodgeStartBtn').style.display = 'none';
                
                // Setup keyboard controls
                this.setupDodgeStarControls();
                
                // Start spawning shields and stars
                this.spawnDodgeShield();
                this.spawnDodgeStar();
                
                // Start game timer
                this.dodgeStarGameInterval = setInterval(() => {
                    this.updateDodgeStarGame();
                }, 50); // 20 FPS
                
                // End game after max time
                setTimeout(() => {
                    if (this.dodgeStarGameActive) {
                        this.endDodgeStarGame('timeout');
                    }
                }, this.dodgeStarData.maxGameTime);
            }
            
            setupDodgeStarControls() {
                // Remove existing listener if any
                if (this.dodgeKeyHandler) {
                    document.removeEventListener('keydown', this.dodgeKeyHandler);
                }
                
                this.dodgeKeyHandler = (event) => {
                    if (!this.dodgeStarGameActive) return;
                    
                    const player = document.getElementById('dodgePlayer');
                    if (!player) return;
                    
                    const moveSpeed = 15;
                    let newX = this.dodgeStarData.playerX;
                    let newY = this.dodgeStarData.playerY;
                    
                    // WASD and Arrow Keys
                    switch(event.key.toLowerCase()) {
                        case 'w':
                        case 'arrowup':
                            newY = Math.max(10, newY - moveSpeed);
                            event.preventDefault();
                            break;
                        case 's':
                        case 'arrowdown':
                            newY = Math.min(360, newY + moveSpeed);
                            event.preventDefault();
                            break;
                        case 'a':
                        case 'arrowleft':
                            newX = Math.max(10, newX - moveSpeed);
                            event.preventDefault();
                            break;
                        case 'd':
                        case 'arrowright':
                            newX = Math.min(460, newX + moveSpeed);
                            event.preventDefault();
                            break;
                    }
                    
                    // Update player position
                    this.dodgeStarData.playerX = newX;
                    this.dodgeStarData.playerY = newY;
                    player.style.left = newX + 'px';
                    player.style.top = newY + 'px';
                };
                
                document.addEventListener('keydown', this.dodgeKeyHandler);
            }
            
            spawnDodgeShield() {
                if (!this.dodgeStarGameActive) return;
                
                const arena = document.getElementById('dodgeShields');
                if (!arena) return;
                
                const shield = document.createElement('div');
                shield.className = 'dodge-shield';
                
                // Random edge position
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: // Top edge
                        x = Math.random() * 470;
                        y = 10;
                        break;
                    case 1: // Right edge
                        x = 470;
                        y = Math.random() * 370;
                        break;
                    case 2: // Bottom edge
                        x = Math.random() * 470;
                        y = 370;
                        break;
                    case 3: // Left edge
                        x = 10;
                        y = Math.random() * 370;
                        break;
                }
                
                shield.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    width: 25px;
                    height: 25px;
                    font-size: 20px;
                    z-index: 50;
                    cursor: pointer;
                `;
                shield.textContent = 'üõ°Ô∏è';
                
                arena.appendChild(shield);
                this.dodgeStarData.shields.push({ element: shield, x, y });
                
                // Shield collection
                shield.onclick = () => {
                    if (!this.dodgeStarGameActive) return;
                    
                    this.dodgeStarData.shieldsCollected++;
                    this.dodgeStarData.totalScore += 5;
                    document.getElementById('shieldsCollected').textContent = this.dodgeStarData.shieldsCollected;
                    document.getElementById('totalStarScore').textContent = this.dodgeStarData.totalScore;
                    
                    shield.remove();
                    this.dodgeStarData.shields = this.dodgeStarData.shields.filter(s => s.element !== shield);
                    
                    console.log('üõ°Ô∏è Shield collected! Total shields:', this.dodgeStarData.shieldsCollected);
                };
                
                // Spawn next shield
                setTimeout(() => {
                    this.spawnDodgeShield();
                }, 3000 + Math.random() * 2000); // 3-5 seconds
            }
            
            spawnDodgeStar() {
                if (!this.dodgeStarGameActive) return;
                
                const arena = document.getElementById('dodgeStars');
                if (!arena) return;
                
                const star = document.createElement('div');
                star.className = 'dodge-star';
                
                const x = Math.random() * 470;
                const fallSpeed = 2 + Math.random() * 3; // 2-5px per frame
                
                star.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: -30px;
                    width: 25px;
                    height: 25px;
                    font-size: 20px;
                    z-index: 75;
                    cursor: pointer;
                `;
                star.textContent = '‚≠ê';
                
                arena.appendChild(star);
                this.dodgeStarData.stars.push({ element: star, x, y: -30, speed: fallSpeed });
                
                // Star collection on click
                star.onclick = () => {
                    if (!this.dodgeStarGameActive) return;
                    
                    this.dodgeStarData.starsCollected++;
                    this.dodgeStarData.totalScore += 2;
                    document.getElementById('starsCollected').textContent = this.dodgeStarData.starsCollected;
                    document.getElementById('totalStarScore').textContent = this.dodgeStarData.totalScore;
                    
                    // Remove star from arrays and DOM
                    star.remove();
                    this.dodgeStarData.stars = this.dodgeStarData.stars.filter(s => s.element !== star);
                    
                    console.log('‚≠ê Star collected! Total stars:', this.dodgeStarData.starsCollected);
                };
                
                // Spawn next star
                setTimeout(() => {
                    this.spawnDodgeStar();
                }, 800 + Math.random() * 400); // 0.8-1.2 seconds
            }
            
            updateDodgeStarGame() {
                if (!this.dodgeStarGameActive) return;
                
                // Update falling stars
                this.dodgeStarData.stars.forEach((star, index) => {
                    star.y += star.speed;
                    star.element.style.top = star.y + 'px';
                    
                    // Check collision with player (auto-collect on touch)
                    const playerX = this.dodgeStarData.playerX;
                    const playerY = this.dodgeStarData.playerY;
                    
                    if (Math.abs(star.x - playerX) < 25 && Math.abs(star.y - playerY) < 25) {
                        // Star touched - auto collect!
                        this.dodgeStarData.starsCollected++;
                        this.dodgeStarData.totalScore += 2;
                        document.getElementById('starsCollected').textContent = this.dodgeStarData.starsCollected;
                        document.getElementById('totalStarScore').textContent = this.dodgeStarData.totalScore;
                        
                        console.log('‚≠ê Star auto-collected by touch! Total stars:', this.dodgeStarData.starsCollected);
                        
                        // Remove star
                        star.element.remove();
                        this.dodgeStarData.stars.splice(index, 1);
                    }
                    
                    // Remove stars that fall off screen (no penalty)
                    else if (star.y > 420) {
                        star.element.remove();
                        this.dodgeStarData.stars.splice(index, 1);
                        console.log('‚≠ê Star fell off screen');
                    }
                });
            }
            
            endDodgeStarGame(reason) {
                console.log('‚≠ê Ending Collect Star game. Reason:', reason);
                
                this.dodgeStarGameActive = false;
                
                // Clear intervals
                if (this.dodgeStarGameInterval) {
                    clearInterval(this.dodgeStarGameInterval);
                }
                
                // Remove keyboard listener
                if (this.dodgeKeyHandler) {
                    document.removeEventListener('keydown', this.dodgeKeyHandler);
                    this.dodgeKeyHandler = null;
                }
                
                // Calculate final score
                const pointChange = this.dodgeStarData.totalScore;
                const resultMessage = `‚≠ê COLLECTION COMPLETE!<br>
                    Stars Collected: ${this.dodgeStarData.starsCollected} (+${this.dodgeStarData.starsCollected * 2} pts)<br>
                    Shields Collected: ${this.dodgeStarData.shieldsCollected} (+${this.dodgeStarData.shieldsCollected * 5} pts)<br>
                    <span style="color: #fbbf24; font-size: 1.3rem;">Total: +${pointChange} points!</span>`;
                
                // Apply score change
                this.gameState.strengthScore += pointChange;
                
                // Show results
                document.getElementById('dodgeResults').innerHTML = resultMessage;
                
                // Show continue button after delay
                setTimeout(() => {
                    document.getElementById('dodgeResults').innerHTML += `
                        <br><br>
                        <button id="dodgeContinueBtn" style="
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                        ">Continue</button>
                    `;
                    
                    const continueBtn = document.getElementById('dodgeContinueBtn');
                    if (continueBtn) {
                        continueBtn.onclick = () => {
                            hideModal('squareModal');
                            if (this.pendingModalCallback) {
                                this.pendingModalCallback();
                                this.pendingModalCallback = null;
                            }
                        };
                    }
                }, 2000);
            }

            // ========== BALLOON BURST MODAL ==========
            showBalloonBurstModal(personas, callback = null) {
                console.log('üéà ShowBalloonBurstModal called with personas:', personas);
                
                document.getElementById('modalTitle').textContent = 'üéà Balloon Burst Challenge';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem; height: 650px; position: relative; overflow: hidden;">
                        <div style="font-size: 1.1rem; margin-bottom: 1rem;">
                            Pop balloons with <strong>SPACEBAR</strong> in 7 seconds!<br>
                            <span style="color: #22c55e; font-weight: bold;">Normal balloons: +2 points each</span><br>
                            <span style="color: #ef4444; font-weight: bold;">‚ö° Spiked balloons: -5 points (avoid!)</span>
                        </div>
                        
                        <div style="font-size: 1.5rem; margin-bottom: 1rem; color: var(--primary-color); font-weight: bold;">
                            Time: <span id="balloonTimer">7.0</span>s
                        </div>
                        
                        <div id="balloonArena" style="
                            width: 500px;
                            height: 400px;
                            background: linear-gradient(180deg, #87ceeb 0%, #e0f6ff 100%);
                            border: 3px solid #3b82f6;
                            border-radius: 12px;
                            position: relative;
                            margin: 0 auto 1rem auto;
                            overflow: hidden;
                        ">
                            <!-- Balloons will spawn here -->
                            <div id="balloonContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                        </div>
                        
                        <div style="display: flex; justify-content: space-around; margin-bottom: 1rem;">
                            <div>Balloons Popped: <span id="balloonsPopped" style="color: #22c55e; font-weight: bold;">0</span></div>
                            <div>Points: <span id="balloonPoints" style="color: var(--primary-color); font-weight: bold;">0</span></div>
                            <div>Spiked Hit: <span id="spikedHit" style="color: #ef4444; font-weight: bold;">0</span></div>
                        </div>
                        
                        <button id="balloonStartBtn" style="
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                        " onmouseover="this.style.background='var(--secondary-color)'" 
                           onmouseout="this.style.background='var(--primary-color)'">
                            Start Balloon Burst!
                        </button>
                        
                        <div id="balloonResults" style="
                            font-size: 1.2rem;
                            margin-top: 1rem;
                            font-weight: bold;
                            min-height: 2rem;
                        "></div>
                    </div>
                `;
                
                // Store callback and initialize game
                this.pendingModalCallback = callback;
                this.balloonBurstGameActive = false;
                this.balloonBurstData = {
                    timeLeft: 7.0,
                    balloonsPopped: 0,
                    spikedHit: 0,
                    points: 0,
                    balloons: [],
                    spikedBalloons: [],
                    gameTimer: null,
                    spawnTimer: null,
                    personas: personas
                };
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Setup game start
                setTimeout(() => {
                    const startBtn = document.getElementById('balloonStartBtn');
                    if (startBtn) {
                        startBtn.onclick = () => {
                            this.startBalloonBurstGame();
                        };
                    }
                }, 100);
            }
            
            startBalloonBurstGame() {
                console.log('üéà Starting Balloon Burst mini-game');
                this.balloonBurstGameActive = true;
                
                // Hide start button
                document.getElementById('balloonStartBtn').style.display = 'none';
                
                // Setup spacebar controls
                this.setupBalloonBurstControls();
                
                // Determine number of spiked balloons (1-5 randomly)
                const spikedCount = Math.floor(Math.random() * 5) + 1;
                console.log(`üéà Game will have ${spikedCount} spiked balloons`);
                
                // Start spawning balloons
                this.spawnBalloon();
                
                // Start game timer (7 seconds)
                this.balloonBurstData.gameTimer = setInterval(() => {
                    this.balloonBurstData.timeLeft -= 0.1;
                    document.getElementById('balloonTimer').textContent = Math.max(0, this.balloonBurstData.timeLeft).toFixed(1);
                    
                    if (this.balloonBurstData.timeLeft <= 0) {
                        this.endBalloonBurstGame();
                    }
                }, 100); // Update every 100ms
                
                // Spawn spiked balloons throughout the game
                this.scheduleSpikedBalloons(spikedCount);
            }
            
            setupBalloonBurstControls() {
                // Remove existing listener if any
                if (this.balloonKeyHandler) {
                    document.removeEventListener('keydown', this.balloonKeyHandler);
                }
                
                this.balloonKeyHandler = (event) => {
                    if (!this.balloonBurstGameActive) return;
                    
                    if (event.code === 'Space') {
                        event.preventDefault();
                        this.popNearestBalloon();
                    }
                };
                
                document.addEventListener('keydown', this.balloonKeyHandler);
            }
            
            spawnBalloon() {
                if (!this.balloonBurstGameActive) return;
                
                const container = document.getElementById('balloonContainer');
                if (!container) return;
                
                const balloon = document.createElement('div');
                balloon.className = 'balloon-normal';
                
                const x = Math.random() * 450; // Random X position
                const y = 420; // Start at bottom
                const speed = 4 + Math.random() * 3; // 4-7px per frame upward (faster!)
                
                // Create balloon image element
                const balloonImg = document.createElement('img');
                balloonImg.src = 'Assets/balloon.png';
                balloonImg.style.cssText = `
                    width: 100%;
                    height: 100%;
                    object-fit: contain;
                `;
                balloonImg.onerror = function() {
                    this.outerHTML = 'üéà'; // Fallback to emoji if image fails
                };
                
                balloon.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    width: 35px;
                    height: 45px;
                    z-index: 50;
                    pointer-events: none;
                    transition: transform 0.1s ease;
                `;
                balloon.appendChild(balloonImg);
                
                container.appendChild(balloon);
                this.balloonBurstData.balloons.push({ 
                    element: balloon, 
                    x, 
                    y, 
                    speed,
                    type: 'normal'
                });
                
                // Continue spawning if game is active
                setTimeout(() => {
                    this.spawnBalloon();
                }, 400 + Math.random() * 300); // 0.4-0.7 seconds (faster spawning for better visibility)
                
                // Move balloon upward
                this.moveBalloon(balloon, x, y, speed);
            }
            
            scheduleSpikedBalloons(count) {
                for (let i = 0; i < count; i++) {
                    const delay = Math.random() * 6000; // Spawn within first 6 seconds
                    setTimeout(() => {
                        if (this.balloonBurstGameActive) {
                            this.spawnSpikedBalloon();
                        }
                    }, delay);
                }
            }
            
            spawnSpikedBalloon() {
                if (!this.balloonBurstGameActive) return;
                
                const container = document.getElementById('balloonContainer');
                if (!container) return;
                
                const spikedBalloon = document.createElement('div');
                spikedBalloon.className = 'balloon-spiked';
                
                const x = Math.random() * 450;
                const y = 420;
                const speed = 5 + Math.random() * 2; // Faster than normal balloons
                
                // Create balloon image element for spiked balloon
                const balloonImg = document.createElement('img');
                balloonImg.src = 'Assets/balloon.png';
                balloonImg.style.cssText = `
                    width: 100%;
                    height: 100%;
                    object-fit: contain;
                    filter: hue-rotate(0deg) saturate(0.5) brightness(0.7);
                `;
                balloonImg.onerror = function() {
                    this.outerHTML = '‚ö°'; // Fallback to lightning emoji if image fails
                };
                
                // Create spike overlay
                const spikeOverlay = document.createElement('div');
                spikeOverlay.textContent = '‚ö°';
                spikeOverlay.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 16px;
                    color: #ef4444;
                    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                    z-index: 10;
                `;
                
                spikedBalloon.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    width: 35px;
                    height: 45px;
                    z-index: 55;
                    pointer-events: none;
                    border: 3px solid #ef4444;
                    border-radius: 20px;
                    background: rgba(239, 68, 68, 0.2);
                    animation: pulse 0.5s infinite alternate;
                `;
                
                spikedBalloon.appendChild(balloonImg);
                spikedBalloon.appendChild(spikeOverlay);
                
                container.appendChild(spikedBalloon);
                this.balloonBurstData.spikedBalloons.push({ 
                    element: spikedBalloon, 
                    x, 
                    y, 
                    speed,
                    type: 'spiked'
                });
                
                console.log('‚ö° Spiked balloon spawned!');
                
                // Remove spiked balloon after 0.4 seconds
                setTimeout(() => {
                    if (spikedBalloon.parentNode) {
                        spikedBalloon.remove();
                        this.balloonBurstData.spikedBalloons = this.balloonBurstData.spikedBalloons.filter(b => b.element !== spikedBalloon);
                    }
                }, 400);
                
                // Move balloon upward
                this.moveBalloon(spikedBalloon, x, y, speed);
            }
            
            moveBalloon(balloon, startX, startY, speed) {
                const moveInterval = setInterval(() => {
                    if (!this.balloonBurstGameActive || !balloon.parentNode) {
                        clearInterval(moveInterval);
                        return;
                    }
                    
                    startY -= speed;
                    balloon.style.top = startY + 'px';
                    
                    // Remove balloon if it goes off screen
                    if (startY < -50) {
                        balloon.remove();
                        clearInterval(moveInterval);
                        
                        // Clean up from arrays
                        this.balloonBurstData.balloons = this.balloonBurstData.balloons.filter(b => b.element !== balloon);
                        this.balloonBurstData.spikedBalloons = this.balloonBurstData.spikedBalloons.filter(b => b.element !== balloon);
                    }
                }, 30); // Increased to ~33 FPS for smoother, faster movement
            }
            
            popNearestBalloon() {
                // Check spiked balloons first (they have priority due to penalty)
                const allSpikedBalloons = this.balloonBurstData.spikedBalloons;
                if (allSpikedBalloons.length > 0) {
                    const spikedBalloon = allSpikedBalloons[0]; // Get first spiked balloon
                    
                    // Pop the spiked balloon (penalty)
                    this.balloonBurstData.spikedHit++;
                    this.balloonBurstData.points -= 5;
                    document.getElementById('spikedHit').textContent = this.balloonBurstData.spikedHit;
                    document.getElementById('balloonPoints').textContent = this.balloonBurstData.points;
                    
                    // Remove balloon
                    spikedBalloon.element.remove();
                    this.balloonBurstData.spikedBalloons = this.balloonBurstData.spikedBalloons.filter(b => b !== spikedBalloon);
                    
                    console.log('‚ö° Spiked balloon popped! -5 points');
                    return;
                }
                
                // Pop normal balloons
                const allNormalBalloons = this.balloonBurstData.balloons;
                if (allNormalBalloons.length > 0) {
                    const balloon = allNormalBalloons[0]; // Get first normal balloon
                    
                    // Pop the normal balloon (bonus)
                    this.balloonBurstData.balloonsPopped++;
                    this.balloonBurstData.points += 2;
                    document.getElementById('balloonsPopped').textContent = this.balloonBurstData.balloonsPopped;
                    document.getElementById('balloonPoints').textContent = this.balloonBurstData.points;
                    
                    // Remove balloon with pop effect
                    balloon.element.style.transform = 'scale(1.5)';
                    balloon.element.style.opacity = '0.5';
                    
                    setTimeout(() => {
                        balloon.element.remove();
                    }, 100);
                    
                    this.balloonBurstData.balloons = this.balloonBurstData.balloons.filter(b => b !== balloon);
                    
                    console.log('üéà Normal balloon popped! +2 points');
                }
            }
            
            endBalloonBurstGame() {
                console.log('üéà Ending Balloon Burst game');
                
                this.balloonBurstGameActive = false;
                
                // Clear timers
                if (this.balloonBurstData.gameTimer) {
                    clearInterval(this.balloonBurstData.gameTimer);
                }
                
                // Remove keyboard listener
                if (this.balloonKeyHandler) {
                    document.removeEventListener('keydown', this.balloonKeyHandler);
                    this.balloonKeyHandler = null;
                }
                
                // Clean up remaining balloons
                this.balloonBurstData.balloons.forEach(b => b.element.remove());
                this.balloonBurstData.spikedBalloons.forEach(b => b.element.remove());
                
                // Apply score change
                const finalPoints = this.balloonBurstData.points;
                this.gameState.strengthScore += finalPoints;
                
                // Show results
                const resultMessage = finalPoints >= 0 
                    ? `üéà SUCCESS! You earned ${finalPoints} points! (${this.balloonBurstData.balloonsPopped} balloons popped, ${this.balloonBurstData.spikedHit} spiked hit)`
                    : `üéà OOPS! You lost ${Math.abs(finalPoints)} points! (${this.balloonBurstData.balloonsPopped} balloons popped, ${this.balloonBurstData.spikedHit} spiked hit)`;
                
                document.getElementById('balloonResults').innerHTML = resultMessage;
                
                // Show continue button after delay
                setTimeout(() => {
                    document.getElementById('balloonResults').innerHTML += `
                        <br><br>
                        <button id="balloonContinueBtn" style="
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                        ">Continue</button>
                    `;
                    
                    const continueBtn = document.getElementById('balloonContinueBtn');
                    if (continueBtn) {
                        continueBtn.onclick = () => {
                            hideModal('squareModal');
                            if (this.pendingModalCallback) {
                                this.pendingModalCallback();
                                this.pendingModalCallback = null;
                            }
                        };
                    }
                }, 2000);
            }

            // ========== COLOR SEQUENCE MODAL ==========
            showColorSequenceModal(personas, callback = null) {
                console.log('üåà ShowColorSequenceModal called with personas:', personas);
                
                document.getElementById('modalTitle').textContent = 'üåà Color Sequence Challenge';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem; height: 650px; position: relative; overflow: hidden;">
                        <div style="font-size: 1.1rem; margin-bottom: 1rem;">
                            Watch the sequence of 4 colored lights for 3 seconds,<br>
                            then repeat with arrow keys:<br>
                            <strong>‚¨ÜÔ∏è = Pink</strong> | <strong>‚¨áÔ∏è = Blue</strong> | <strong>‚¨ÖÔ∏è = Green</strong> | <strong>‚û°Ô∏è = Yellow</strong>
                        </div>
                        
                        <div style="font-size: 1.5rem; margin-bottom: 1rem; color: var(--primary-color); font-weight: bold;">
                            <span id="colorStatus">Get Ready...</span>
                        </div>
                        
                        <div id="colorGrid" style="
                            display: grid;
                            grid-template-columns: 1fr 1fr;
                            grid-template-rows: 1fr 1fr;
                            gap: 20px;
                            width: 300px;
                            height: 300px;
                            margin: 0 auto 2rem auto;
                            padding: 20px;
                            background: #1f2937;
                            border-radius: 12px;
                            border: 3px solid #3b82f6;
                        ">
                            <div id="colorPink" class="color-light" style="
                                background: #fbb6ce;
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 2rem;
                                font-weight: bold;
                                transition: all 0.3s ease;
                                opacity: 0.3;
                            ">‚¨ÜÔ∏è</div>
                            <div id="colorBlue" class="color-light" style="
                                background: #93c5fd;
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 2rem;
                                font-weight: bold;
                                transition: all 0.3s ease;
                                opacity: 0.3;
                            ">‚¨áÔ∏è</div>
                            <div id="colorGreen" class="color-light" style="
                                background: #86efac;
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 2rem;
                                font-weight: bold;
                                transition: all 0.3s ease;
                                opacity: 0.3;
                            ">‚¨ÖÔ∏è</div>
                            <div id="colorYellow" class="color-light" style="
                                background: #fde047;
                                border-radius: 12px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 2rem;
                                font-weight: bold;
                                transition: all 0.3s ease;
                                opacity: 0.3;
                            ">‚û°Ô∏è</div>
                        </div>
                        
                        <div style="display: flex; justify-content: space-around; margin-bottom: 1rem;">
                            <div>Sequence: <span id="sequenceLength" style="color: var(--primary-color); font-weight: bold;">4</span> colors</div>
                            <div>Your Input: <span id="playerInput" style="color: #22c55e; font-weight: bold;">-</span></div>
                        </div>
                        
                        <button id="colorStartBtn" style="
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                        " onmouseover="this.style.background='var(--secondary-color)'" 
                           onmouseout="this.style.background='var(--primary-color)'">
                            Start Color Challenge!
                        </button>
                        
                        <div id="colorResults" style="
                            font-size: 1.2rem;
                            margin-top: 1rem;
                            font-weight: bold;
                            min-height: 4rem;
                            max-width: 100%;
                        "></div>
                    </div>
                `;
                
                // Store callback and initialize game
                this.pendingModalCallback = callback;
                this.colorSequenceGameActive = false;
                this.colorSequenceData = {
                    sequence: [],
                    playerSequence: [],
                    currentStep: 0,
                    gamePhase: 'waiting', // waiting, showing, input, complete
                    personas: personas,
                    colors: ['pink', 'blue', 'green', 'yellow'],
                    keyMappings: {
                        'ArrowUp': 'pink',
                        'ArrowDown': 'blue', 
                        'ArrowLeft': 'green',
                        'ArrowRight': 'yellow'
                    }
                };
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Setup game start
                setTimeout(() => {
                    const startBtn = document.getElementById('colorStartBtn');
                    if (startBtn) {
                        startBtn.onclick = () => {
                            this.startColorSequenceGame();
                        };
                    }
                }, 100);
            }
            
            startColorSequenceGame() {
                console.log('üåà Starting Color Sequence mini-game');
                this.colorSequenceGameActive = true;
                
                // Hide start button
                document.getElementById('colorStartBtn').style.display = 'none';
                
                // Generate random sequence of 4 colors
                this.colorSequenceData.sequence = [];
                for (let i = 0; i < 4; i++) {
                    const randomColor = this.colorSequenceData.colors[Math.floor(Math.random() * 4)];
                    this.colorSequenceData.sequence.push(randomColor);
                }
                
                console.log('üåà Generated sequence:', this.colorSequenceData.sequence);
                
                // Update status
                document.getElementById('colorStatus').textContent = 'Watch the sequence...';
                
                // Start sequence showing phase after 1 second
                setTimeout(() => {
                    this.showColorSequence();
                }, 1000);
            }
            
            showColorSequence() {
                this.colorSequenceData.gamePhase = 'showing';
                this.colorSequenceData.currentStep = 0;
                
                const showNextColor = () => {
                    if (this.colorSequenceData.currentStep >= this.colorSequenceData.sequence.length) {
                        // Sequence complete, start input phase
                        this.startInputPhase();
                        return;
                    }
                    
                    const colorToShow = this.colorSequenceData.sequence[this.colorSequenceData.currentStep];
                    
                    // Flash the color
                    this.flashColor(colorToShow, () => {
                        this.colorSequenceData.currentStep++;
                        
                        // Show next color after brief delay
                        setTimeout(showNextColor, 200);
                    });
                };
                
                showNextColor();
            }
            
            flashColor(color, callback) {
                const colorElement = document.getElementById(`color${color.charAt(0).toUpperCase() + color.slice(1)}`);
                if (!colorElement) return;
                
                // Flash bright
                colorElement.style.opacity = '1';
                colorElement.style.transform = 'scale(1.1)';
                colorElement.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.8)';
                
                setTimeout(() => {
                    // Dim back down
                    colorElement.style.opacity = '0.3';
                    colorElement.style.transform = 'scale(1)';
                    colorElement.style.boxShadow = 'none';
                    
                    if (callback) callback();
                }, 750); // Each flash lasts 0.75 seconds
            }
            
            startInputPhase() {
                this.colorSequenceData.gamePhase = 'input';
                this.colorSequenceData.playerSequence = [];
                
                // Update status
                document.getElementById('colorStatus').textContent = 'Repeat the sequence with arrow keys!';
                document.getElementById('playerInput').textContent = '';
                
                // Setup keyboard controls
                this.setupColorSequenceControls();
                
                console.log('üåà Input phase started. Waiting for player input...');
            }
            
            setupColorSequenceControls() {
                // Remove existing listener if any
                if (this.colorKeyHandler) {
                    document.removeEventListener('keydown', this.colorKeyHandler);
                }
                
                this.colorKeyHandler = (event) => {
                    if (!this.colorSequenceGameActive || this.colorSequenceData.gamePhase !== 'input') return;
                    
                    const color = this.colorSequenceData.keyMappings[event.key];
                    if (color) {
                        event.preventDefault();
                        this.handleColorInput(color);
                    }
                };
                
                document.addEventListener('keydown', this.colorKeyHandler);
            }
            
            handleColorInput(color) {
                console.log('üåà Player input:', color);
                
                // Add to player sequence
                this.colorSequenceData.playerSequence.push(color);
                
                // Update display
                const inputDisplay = this.colorSequenceData.playerSequence.map(c => {
                    const symbols = { pink: '‚¨ÜÔ∏è', blue: '‚¨áÔ∏è', green: '‚¨ÖÔ∏è', yellow: '‚û°Ô∏è' };
                    return symbols[c] || c;
                }).join(' ');
                document.getElementById('playerInput').textContent = inputDisplay;
                
                // Flash the selected color briefly
                this.flashColor(color, null);
                
                // Check if sequence is complete
                if (this.colorSequenceData.playerSequence.length >= 4) {
                    // Check if correct
                    this.checkColorSequence();
                } else {
                    // Check if current input is correct so far
                    const currentIndex = this.colorSequenceData.playerSequence.length - 1;
                    const expectedColor = this.colorSequenceData.sequence[currentIndex];
                    
                    if (color !== expectedColor) {
                        // Wrong color - end immediately
                        this.endColorSequenceGame(false);
                    }
                }
            }
            
            checkColorSequence() {
                const playerSeq = this.colorSequenceData.playerSequence;
                const correctSeq = this.colorSequenceData.sequence;
                
                // Check if sequences match
                const isCorrect = playerSeq.length === correctSeq.length && 
                                  playerSeq.every((color, index) => color === correctSeq[index]);
                
                console.log('üåà Sequence check:', {
                    player: playerSeq,
                    correct: correctSeq,
                    isCorrect: isCorrect
                });
                
                this.endColorSequenceGame(isCorrect);
            }
            
            endColorSequenceGame(success) {
                console.log('üåà Ending Color Sequence game. Success:', success);
                
                this.colorSequenceGameActive = false;
                this.colorSequenceData.gamePhase = 'complete';
                
                // Remove keyboard listener
                if (this.colorKeyHandler) {
                    document.removeEventListener('keydown', this.colorKeyHandler);
                    this.colorKeyHandler = null;
                }
                
                // Calculate score and show result
                let pointChange = 0;
                let resultMessage = '';
                
                if (success) {
                    pointChange = 15;
                    resultMessage = 'üåà PERFECT! You repeated the sequence correctly. +15 points!';
                    document.getElementById('colorStatus').textContent = 'SUCCESS!';
                    
                    // Flash all colors in celebration
                    this.colorSequenceData.colors.forEach((color, index) => {
                        setTimeout(() => {
                            this.flashColor(color, null);
                        }, index * 100);
                    });
                } else {
                    pointChange = -10;
                    resultMessage = 'üåà WRONG! You made a mistake in the sequence. -10 points!';
                    document.getElementById('colorStatus').textContent = 'FAILED!';
                }
                
                // Apply score change
                this.gameState.strengthScore += pointChange;
                
                // Update game stats immediately
                this.updateGameStats();
                
                // Store success state for button creation
                const gameSuccess = success;
                
                // Show results
                document.getElementById('colorResults').innerHTML = resultMessage;
                
                // Show continue button after delay
                setTimeout(() => {
                    const correctSeq = this.colorSequenceData.sequence.map(c => {
                        const symbols = { pink: '‚¨ÜÔ∏è', blue: '‚¨áÔ∏è', green: '‚¨ÖÔ∏è', yellow: '‚û°Ô∏è' };
                        return symbols[c];
                    }).join(' ');
                    
                    const playerSeq = this.colorSequenceData.playerSequence.map(c => {
                        const symbols = { pink: '‚¨ÜÔ∏è', blue: '‚¨áÔ∏è', green: '‚¨ÖÔ∏è', yellow: '‚û°Ô∏è' };
                        return symbols[c];
                    }).join(' ');
                    
                    document.getElementById('colorResults').innerHTML += `
                        <div style="margin: 1.5rem 0; padding: 1rem; background: rgba(0,0,0,0.1); border-radius: 8px;">
                            <div style="font-size: 1rem; margin-bottom: 0.5rem; color: #22c55e;">
                                <strong>Correct Sequence:</strong> ${correctSeq}
                            </div>
                            <div style="font-size: 1rem; color: ${gameSuccess ? '#22c55e' : '#ef4444'};">
                                <strong>Your Sequence:</strong> ${playerSeq}
                            </div>
                        </div>
                        <button id="colorContinueBtn" style="
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 2rem;
                            border-radius: 8px;
                            font-size: 1.1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                            margin-top: 1rem;
                        " onmouseover="this.style.background='var(--secondary-color)'; this.style.transform='translateY(-2px)'" 
                           onmouseout="this.style.background='var(--primary-color)'; this.style.transform='translateY(0)'">
                            Continue Game üéÆ
                        </button>
                    `;
                    
                    const continueBtn = document.getElementById('colorContinueBtn');
                    if (continueBtn) {
                        // Add focus for accessibility
                        continueBtn.focus();
                        
                        continueBtn.onclick = () => {
                            console.log('üåà Continue button clicked - closing modal and ending turn');
                            hideModal('squareModal');
                            if (this.pendingModalCallback) {
                                this.pendingModalCallback();
                                this.pendingModalCallback = null;
                            }
                        };
                    }
                }, 2500); // Slightly longer delay to ensure visibility
            }

            // ========== STORM SHIFT MODAL ==========
            showStormShiftModal(callback = null) {
                console.log('üå©Ô∏è ShowStormShiftModal called');
                
                document.getElementById('modalTitle').innerHTML = 'üå©Ô∏è Storm Shift';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.1rem; margin-bottom: 1.5rem;">A storm reshuffles tiles on the board!</div>
                        
                        <div id="stormAnimation" style="
                            width: 100%;
                            height: 150px;
                            background: linear-gradient(45deg, #1e293b, #334155);
                            border-radius: 12px;
                            position: relative;
                            overflow: hidden;
                            margin: 1.5rem 0;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">
                            <div id="stormClouds" style="
                                position: absolute;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                background: repeating-linear-gradient(
                                    90deg,
                                    rgba(255, 255, 255, 0.1) 0%,
                                    rgba(255, 255, 255, 0.3) 50%,
                                    rgba(255, 255, 255, 0.1) 100%
                                );
                                animation: stormMovement 2s infinite;
                            "></div>
                            
                            <div style="
                                font-size: 3rem;
                                z-index: 2;
                                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                            ">‚ö°üå©Ô∏è‚ö°</div>
                        </div>
                        
                        <div id="stormInstructions" style="
                            font-size: 1rem;
                            margin-bottom: 1.5rem;
                            color: var(--primary-color);
                            font-weight: 600;
                        ">Click "Shuffle" to unleash the storm!</div>
                        
                        <button id="shuffleButton" style="
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                        " onmouseover="this.style.background='var(--secondary-color)'" 
                           onmouseout="this.style.background='var(--primary-color)'">
                            Shuffle ‚ö°
                        </button>
                    </div>
                `;
                
                // Store callback
                this.pendingModalCallback = callback;
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Setup shuffle button click handler
                setTimeout(() => {
                    const shuffleBtn = document.getElementById('shuffleButton');
                    if (shuffleBtn) {
                        shuffleBtn.onclick = () => {
                            console.log('üå©Ô∏è Shuffle button clicked, closing modal and starting storm');
                            
                            // Close the modal immediately
                            hideModal('squareModal');
                            
                            // Start storm sequence after modal is closed
                            setTimeout(() => {
                                this.startStormSequence();
                            }, 300); // Small delay to ensure modal is fully closed
                        };
                    }
                }, 100);
            }

            startStormSequence() {
                console.log('üå©Ô∏è Starting storm sequence with modal closed');
                
                // 1. Start screen greying effect
                this.createScreenGreyEffect();
                
                // 2. Storm.png flies in from left (delay to let grey effect start)
                setTimeout(() => {
                    this.animateStormCloud(() => {
                        // 3. Perform tile swapping while storm lingers
                        this.swapRandomTiles();
                        console.log('üå©Ô∏è Storm complete, tiles rearranged');
                        
                        // 4. End turn after storm effects complete
                        setTimeout(() => {
                            if (this.pendingModalCallback) {
                                this.pendingModalCallback();
                                this.pendingModalCallback = null;
                            }
                        }, 1500);
                    });
                }, 500);
            }

            createScreenGreyEffect() {
                // Create grey overlay
                const greyOverlay = document.createElement('div');
                greyOverlay.id = 'stormGreyOverlay';
                greyOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(128, 128, 128, 0.6);
                    z-index: 500;
                    opacity: 0;
                    transition: opacity 1s ease-in-out;
                    pointer-events: none;
                `;
                document.body.appendChild(greyOverlay);
                
                // Fade in grey effect
                setTimeout(() => {
                    greyOverlay.style.opacity = '1';
                }, 50);
                
                // Remove grey effect after storm sequence
                setTimeout(() => {
                    greyOverlay.style.opacity = '0';
                    setTimeout(() => {
                        if (greyOverlay.parentNode) {
                            greyOverlay.parentNode.removeChild(greyOverlay);
                        }
                    }, 1000);
                }, 6000);
            }

            animateStormCloud(callback) {
                // Create storm.png element
                const stormCloud = document.createElement('img');
                stormCloud.src = 'Assets/storm.png';
                stormCloud.style.cssText = `
                    position: fixed;
                    width: 600px;
                    height: 600px;
                    object-fit: contain;
                    top: 50%;
                    left: -650px;
                    transform: translateY(-50%);
                    z-index: 1001;
                    pointer-events: none;
                    transition: none;
                `;
                stormCloud.onerror = () => {
                    // Fallback if storm.png doesn't load
                    stormCloud.innerHTML = 'üå™Ô∏è';
                    stormCloud.style.fontSize = '300px';
                    stormCloud.style.textAlign = 'center';
                    stormCloud.style.lineHeight = '600px';
                };
                document.body.appendChild(stormCloud);
                
                // Phase 1: Fly in from left
                setTimeout(() => {
                    stormCloud.style.transition = 'left 2s ease-in-out';
                    stormCloud.style.left = '50%';
                    stormCloud.style.transform = 'translateX(-50%) translateY(-50%)';
                }, 100);
                
                // Phase 2: Linger in center during tile swap
                setTimeout(() => {
                    console.log('üå©Ô∏è Storm cloud lingering, executing tile swap');
                    
                    // Callback executes tile swapping while storm lingers
                    if (callback) callback();
                }, 2200);
                
                // Phase 3: Exit to right
                setTimeout(() => {
                    stormCloud.style.transition = 'left 2s ease-in-out';
                    stormCloud.style.left = 'calc(100vw + 650px)';
                    stormCloud.style.transform = 'translateY(-50%)';
                }, 4000);
                
                // Cleanup storm cloud
                setTimeout(() => {
                    if (stormCloud.parentNode) {
                        stormCloud.parentNode.removeChild(stormCloud);
                    }
                }, 6500);
            }

            swapRandomTiles() {
                // Get tiles ahead of player that are not connected to ladders/chutes
                const validTiles = this.getValidTilesForStorm();
                
                if (validTiles.length < 6) {
                    console.log('Not enough valid tiles for storm swap');
                    return;
                }
                
                // Randomly select 3 tiles for first group  
                const shuffled = [...validTiles].sort(() => Math.random() - 0.5);
                const firstGroup = shuffled.slice(0, 3);
                
                // Randomly select 3 different tiles for second group
                const remaining = shuffled.slice(3);
                const secondGroup = remaining.slice(0, 3);
                
                console.log(`üå©Ô∏è Storm swapping tiles: [${firstGroup.join(', ')}] with [${secondGroup.join(', ')}]`);
                
                // Start the animated tile shuffle
                this.animateShuffleTiles(firstGroup, secondGroup);
            }

            animateShuffleTiles(group1, group2) {
                const allPositions = [...group1, ...group2];
                const animatedTiles = [];
                
                // Step 1: Create animated clones of the tiles and hide originals
                allPositions.forEach(position => {
                    const originalSquare = document.querySelector(`[data-position="${position}"]`);
                    if (!originalSquare) return;
                    
                    // Get the position of the original square
                    const rect = originalSquare.getBoundingClientRect();
                    const boardRect = document.getElementById('gameBoard').getBoundingClientRect();
                    
                    // Create animated clone
                    const clone = originalSquare.cloneNode(true);
                    clone.id = `animated-tile-${position}`;
                    clone.style.position = 'absolute';
                    clone.style.left = `${rect.left - boardRect.left}px`;
                    clone.style.top = `${rect.top - boardRect.top}px`;
                    clone.style.width = `${rect.width}px`;
                    clone.style.height = `${rect.height}px`;
                    clone.style.zIndex = '1000';
                    clone.style.pointerEvents = 'none';
                    clone.style.transition = 'all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                    clone.style.boxShadow = '0 8px 25px rgba(0, 0, 0, 0.3)';
                    
                    // Add to board container
                    document.getElementById('gameBoard').appendChild(clone);
                    animatedTiles.push({
                        clone: clone,
                        position: position,
                        originalSquare: originalSquare,
                        startRect: rect
                    });
                    
                    // Hide original tile
                    originalSquare.style.opacity = '0.3';
                });
                
                // Step 2: Lift tiles up and move them to center
                setTimeout(() => {
                    const boardCenter = document.getElementById('gameBoard').getBoundingClientRect();
                    const centerX = boardCenter.width / 2;
                    const centerY = boardCenter.height / 2;
                    
                    animatedTiles.forEach((tile, index) => {
                        // Lift up and move to center area in a circle formation
                        const angle = (index / animatedTiles.length) * Math.PI * 2;
                        const radius = 40;
                        const offsetX = Math.cos(angle) * radius;
                        const offsetY = Math.sin(angle) * radius;
                        
                        tile.clone.style.left = `${centerX + offsetX - 40}px`;
                        tile.clone.style.top = `${centerY + offsetY - 40}px`;
                        tile.clone.style.transform = 'translateZ(0) rotateY(360deg) scale(1.1)';
                    });
                }, 100);
                
                // Step 3: Shuffle around in center
                setTimeout(() => {
                    animatedTiles.forEach((tile, index) => {
                        const angle = ((index + 3) / animatedTiles.length) * Math.PI * 2; // Different positions
                        const radius = 60;
                        const offsetX = Math.cos(angle) * radius;
                        const offsetY = Math.sin(angle) * radius;
                        
                        const boardCenter = document.getElementById('gameBoard').getBoundingClientRect();
                        const centerX = boardCenter.width / 2;
                        const centerY = boardCenter.height / 2;
                        
                        tile.clone.style.left = `${centerX + offsetX - 40}px`;
                        tile.clone.style.top = `${centerY + offsetY - 40}px`;
                        tile.clone.style.transform = 'translateZ(0) rotateY(720deg) scale(1.0)';
                    });
                }, 800);
                
                // Step 4: Move tiles to their new positions and swap data
                setTimeout(() => {
                    // Perform the actual data swap
                    for (let i = 0; i < 3; i++) {
                        const pos1 = group1[i];
                        const pos2 = group2[i];
                        
                        // Get the square elements
                        const square1 = document.querySelector(`[data-position="${pos1}"]`);
                        const square2 = document.querySelector(`[data-position="${pos2}"]`);
                        
                        if (square1 && square2) {
                            // Swap the visual content (classes and text) 
                            const temp1Classes = square1.className;
                            const temp1Content = square1.innerHTML;
                            
                            square1.className = square2.className;
                            square1.innerHTML = square2.innerHTML;
                            
                            square2.className = temp1Classes;
                            square2.innerHTML = temp1Content;
                        }
                    }
                    
                    // Move animated tiles to their new destinations
                    animatedTiles.forEach((tile, index) => {
                        let newPosition;
                        if (group1.includes(tile.position)) {
                            // This tile goes to its counterpart in group2
                            const groupIndex = group1.indexOf(tile.position);
                            newPosition = group2[groupIndex];
                        } else {
                            // This tile goes to its counterpart in group1
                            const groupIndex = group2.indexOf(tile.position);
                            newPosition = group1[groupIndex];
                        }
                        
                        const newSquare = document.querySelector(`[data-position="${newPosition}"]`);
                        if (newSquare) {
                            const newRect = newSquare.getBoundingClientRect();
                            const boardRect = document.getElementById('gameBoard').getBoundingClientRect();
                            
                            tile.clone.style.left = `${newRect.left - boardRect.left}px`;
                            tile.clone.style.top = `${newRect.top - boardRect.top}px`;
                            tile.clone.style.transform = 'translateZ(0) rotateY(0deg) scale(1.0)';
                            tile.clone.style.boxShadow = '0 4px 15px rgba(251, 191, 36, 0.6)';
                        }
                    });
                }, 1500);
                
                // Step 5: Clean up - remove clones and restore originals
                setTimeout(() => {
                    animatedTiles.forEach(tile => {
                        tile.originalSquare.style.opacity = '1';
                        tile.originalSquare.style.boxShadow = '0 0 15px #fbbf24';
                        tile.clone.remove();
                        
                        // Remove highlight after a moment
                        setTimeout(() => {
                            tile.originalSquare.style.boxShadow = '';
                        }, 1000);
                    });
                    
                    console.log('üå©Ô∏è Tile shuffle animation complete!');
                }, 2300);
            }

            getValidTilesForStorm() {
                const validTiles = [];
                const playerPos = this.gameState.currentPosition;
                
                // Get all ladder and chute connection positions
                const connectedPositions = new Set();
                
                // Add all ladder start and end positions
                this.gameState.board.ladders.forEach(ladder => {
                    connectedPositions.add(ladder.start);
                    connectedPositions.add(ladder.end);
                });
                
                // Add all chute start and end positions
                this.gameState.board.chutes.forEach(chute => {
                    connectedPositions.add(chute.start);
                    connectedPositions.add(chute.end);
                });
                
                // Check tiles ahead of player that are not visited and not connected
                for (let i = playerPos + 1; i <= 100; i++) {
                    if (!this.gameState.visitedTiles.has(i) && !connectedPositions.has(i)) {
                        validTiles.push(i);
                    }
                }
                
                console.log(`üå©Ô∏è Found ${validTiles.length} valid tiles for storm swap:`, validTiles);
                console.log(`üå©Ô∏è Connected positions to avoid:`, Array.from(connectedPositions).sort((a,b) => a-b));
                
                return validTiles;
            }

            // ========== PHANTOM TELEPORT MODAL ==========
            showTradePlacesModal(callback = null) {
                console.log('üëª ShowPhantomTeleportModal called');
                
                document.getElementById('modalTitle').innerHTML = '<img src="Assets/ghost.png" style="width: 24px; height: 24px; object-fit: contain; vertical-align: middle;" onerror="this.outerHTML=\'üëª\'"> Phantom Teleport';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.1rem; margin-bottom: 1.5rem;">Phantom ghost is flying across the screen... are you ready to teleport to him?</div>
                        
                        <div id="phantomCountdown" style="
                            font-size: 3rem;
                            font-weight: bold;
                            color: var(--primary-color);
                            margin: 2rem 0;
                        ">5</div>
                        
                        <div style="
                            font-size: 0.9rem;
                            color: #6b7280;
                            margin-top: 1rem;
                        ">Get ready to press SPACEBAR when the ghost appears!</div>
                    </div>
                `;
                
                // Store callback and initialize state
                this.pendingModalCallback = callback;
                this.phantomActive = false;
                this.phantomPosition = 1;
                this.phantomCountdown = 5;
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Start countdown
                setTimeout(() => {
                    this.startPhantomCountdown();
                }, 500);
            }

            startPhantomCountdown() {
                console.log('üëª Starting 5 second countdown');
                const countdownElement = document.getElementById('phantomCountdown');
                
                const countdown = () => {
                    if (this.phantomCountdown <= 0) {
                        console.log('üëª Countdown complete, closing modal and starting ghost flight');
                        // Close modal and start ghost flight
                        hideModal('squareModal');
                        setTimeout(() => {
                            this.startPhantomFlight();
                        }, 300);
                        return;
                    }
                    
                    countdownElement.textContent = this.phantomCountdown;
                    this.phantomCountdown--;
                    
                    setTimeout(countdown, 1000);
                };
                
                countdown();
            }

            startPhantomFlight() {
                console.log('üëª Starting 10-second phantom flight');
                this.phantomActive = true;
                this.phantomFlightStartTime = Date.now();
                this.phantomMaxFlightTime = 10000; // 10 seconds
                
                // Create ghost.png flying around the screen
                this.phantomGhost = document.createElement('img');
                this.phantomGhost.src = 'Assets/ghost.png';
                this.phantomGhost.style.cssText = `
                    position: fixed;
                    width: 60px;
                    height: 60px;
                    object-fit: contain;
                    z-index: 1001;
                    pointer-events: none;
                    transition: all 0.3s ease-in-out;
                `;
                this.phantomGhost.onerror = () => {
                    // Fallback if ghost.png doesn't load
                    this.phantomGhost.innerHTML = 'üëª';
                    this.phantomGhost.style.fontSize = '60px';
                    this.phantomGhost.style.textAlign = 'center';
                    this.phantomGhost.style.lineHeight = '60px';
                };
                document.body.appendChild(this.phantomGhost);
                
                // Add keyboard listener for spacebar
                this.phantomKeyHandler = (e) => {
                    if (e.code === 'Space' && this.phantomActive) {
                        e.preventDefault();
                        console.log(`üëª Spacebar pressed! Teleporting to position ${this.phantomPosition}`);
                        this.capturePhantom();
                    }
                };
                document.addEventListener('keydown', this.phantomKeyHandler);
                
                // Start moving phantom around screen and board
                this.movePhantomAroundBoard();
                
                // Auto-teleport after 10 seconds if no spacebar press
                this.phantomTimeout = setTimeout(() => {
                    if (this.phantomActive) {
                        console.log(`üëª Time's up! Auto-teleporting to position ${this.phantomPosition}`);
                        this.capturePhantom();
                    }
                }, this.phantomMaxFlightTime);
            }

            movePhantomAroundBoard() {
                if (!this.phantomActive) return;
                
                // Generate random position on board (1-50 for valid board positions)
                this.phantomPosition = Math.floor(Math.random() * 50) + 1;
                
                // Get the square element for that position
                const targetSquare = document.querySelector(`[data-position="${this.phantomPosition}"]`);
                
                if (targetSquare && this.phantomGhost) {
                    // Position ghost over the target square
                    const rect = targetSquare.getBoundingClientRect();
                    this.phantomGhost.style.left = (rect.left + rect.width/2 - 30) + 'px';
                    this.phantomGhost.style.top = (rect.top + rect.height/2 - 30) + 'px';
                }
                
                // Continue moving every 300ms for smooth tracking
                if (this.phantomActive) {
                    setTimeout(() => {
                        this.movePhantomAroundBoard();
                    }, 300);
                }
            }

            capturePhantom() {
                console.log(`üëª Capturing phantom at position ${this.phantomPosition}`);
                this.phantomActive = false;
                
                // Clear timeout if it exists
                if (this.phantomTimeout) {
                    clearTimeout(this.phantomTimeout);
                }
                
                // Remove keyboard listener
                document.removeEventListener('keydown', this.phantomKeyHandler);
                
                // Fade out ghost
                if (this.phantomGhost) {
                    this.phantomGhost.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-out';
                    this.phantomGhost.style.opacity = '0';
                    this.phantomGhost.style.transform = 'scale(0.5)';
                    
                    setTimeout(() => {
                        if (this.phantomGhost && this.phantomGhost.parentNode) {
                            this.phantomGhost.parentNode.removeChild(this.phantomGhost);
                        }
                    }, 500);
                }
                
                // Show teleportation confirmation modal
                setTimeout(() => {
                    this.showTeleportConfirmation(this.phantomPosition);
                }, 600);
            }

            showTeleportConfirmation(targetPosition) {
                console.log(`üëª Showing teleport confirmation to position ${targetPosition}`);
                
                document.getElementById('modalTitle').innerHTML = '<img src="Assets/ghost.png" style="width: 24px; height: 24px; object-fit: contain; vertical-align: middle;" onerror="this.outerHTML=\'üëª\'"> Teleported!';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.2rem; margin-bottom: 1rem;">You've been teleported!</div>
                        <div style="font-size: 1rem; color: #6b7280;">Moving to position ${targetPosition}...</div>
                    </div>
                `;
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Auto-close after 2 seconds and move player
                setTimeout(() => {
                    hideModal('squareModal');
                    this.executePhantomTeleport(targetPosition);
                }, 2000);
            }

            executePhantomTeleport(targetPosition) {
                console.log(`üëª Executing teleport to position ${targetPosition}`);
                
                // Update game state
                this.gameState.currentPosition = targetPosition;
                this.updatePlayerPosition();
                
                // Re-enable dice for next roll instead of ending turn
                setTimeout(() => {
                    console.log('üëª Teleportation complete, enabling dice for next roll');
                    this.gameState.canRoll = true;
                    document.getElementById('rollDiceBtn').disabled = false;
                    
                    // Clear pending callback since we're not ending the turn
                    this.pendingModalCallback = null;
                }, 500);
            }

            // ========== DOUBLE TROUBLE MODAL ==========
            showDoubleTroubleModal(callback = null) {
                console.log('üéØ ShowDoubleTroubleModal called');
                
                document.getElementById('modalTitle').textContent = 'üéØ Double Trouble';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.1rem; margin-bottom: 1.5rem;">Next roll is doubled!</div>
                        
                        <div id="diceGlowContainer" style="
                            display: flex;
                            justify-content: center;
                            margin: 2rem 0;
                        ">
                            <div id="glowingDice" style="
                                font-size: 4rem;
                                background: radial-gradient(circle, #fbbf24, #f59e0b);
                                -webkit-background-clip: text;
                                -webkit-text-fill-color: transparent;
                                background-clip: text;
                                filter: drop-shadow(0 0 20px #fbbf24);
                                animation: diceGlow 2s infinite alternate;
                            ">üé≤</div>
                        </div>
                        
                        <div style="
                            background: linear-gradient(135deg, #fbbf24, #f59e0b);
                            color: white;
                            padding: 1rem;
                            border-radius: 12px;
                            font-weight: 600;
                            margin: 1rem 0;
                        ">
                            Your next dice roll will be multiplied by 2!
                        </div>
                        
                        <div style="font-size: 0.9rem; color: var(--text-color); opacity: 0.8;">
                            The dice will glow until your next turn to remind you of this effect.
                        </div>
                    </div>
                `;
                
                // Store callback
                this.pendingModalCallback = callback;
                
                // Apply the double roll effect
                this.gameState.activeDebuffs.push({
                    type: 'doubleRoll',
                    description: 'Next dice roll doubled',
                    turnsRemaining: 1,
                    color: '#fbbf24'
                });
                
                this.updateDebuffsDisplay();
                
                showModal('squareModal');
                
                // Auto-close after showing the effect
                setTimeout(() => {
                    hideModal('squareModal');
                }, 3000);
            }

            showMysteryBagModal(callback = null) {
                console.log('üéí ShowMysteryBagModal called');
                
                document.getElementById('modalTitle').innerHTML = '<img src="Assets/backpack.png" style="width: 24px; height: 24px; object-fit: contain; vertical-align: middle;" onerror="this.outerHTML=\'üéí\'"> Mystery Bag';
                document.getElementById('modalContent').innerHTML = `
                    <div style="text-align: center; padding: 1rem;">
                        <div style="font-size: 1.1rem; margin-bottom: 2rem;">Click the bag to see what's inside!</div>
                        
                        <div style="display: flex; justify-content: center; margin-bottom: 2rem;">
                            <div id="mysteryBagContainer" style="position: relative;">
                                <div id="mysteryBag" style="
                                    font-size: 180px;
                                    cursor: pointer;
                                    transition: transform 0.1s ease;
                                    user-select: none;
                                "><img src="Assets/backpack.png" style="width: 180px; height: 180px; object-fit: contain;" onerror="this.outerHTML='üéí'; this.style.fontSize='180px';"></div>
                            </div>
                        </div>
                        
                        <div id="bagInstructions" style="font-size: 1rem; margin-bottom: 1.5rem; color: var(--primary-color); font-weight: 600;">
                            Click the backpack!
                        </div>
                        
                        <div id="bagResultAnimation" style="
                            position: relative; 
                            height: 80px; 
                            margin-bottom: 1rem;
                            display: flex;
                            justify-content: center;
                            align-items: center;
                        "></div>
                        
                        <div id="bagResult" style="font-size: 1.2rem; font-weight: 600; margin-bottom: 1.5rem; min-height: 3rem; color: var(--text-color);"></div>
                        
                        <button id="bagContinueButton" style="
                            display: none;
                            background: var(--primary-color);
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 8px;
                            font-size: 1rem;
                            font-weight: 600;
                            cursor: pointer;
                            transition: background 0.3s ease;
                            font-family: 'Space Grotesk', sans-serif;
                        " onmouseover="this.style.background='var(--secondary-color)'" 
                           onmouseout="this.style.background='var(--primary-color)'">
                            Continue
                        </button>
                    </div>
                `;
                
                // Store callback
                this.pendingModalCallback = callback;
                this.bagOpened = false;
                this.bagResult = null;
                
                // Hide the default modal footer
                document.getElementById('defaultModalFooter').style.display = 'none';
                
                showModal('squareModal');
                
                // Setup bag click handler
                setTimeout(() => {
                    const bag = document.getElementById('mysteryBag');
                    if (bag) {
                        bag.onclick = () => {
                            if (!this.bagOpened) {
                                this.openMysteryBag();
                            }
                        };
                        
                        // Add hover effect
                        bag.onmouseover = () => {
                            if (!this.bagOpened) {
                                bag.style.transform = 'scale(1.05)';
                            }
                        };
                        bag.onmouseout = () => {
                            if (!this.bagOpened) {
                                bag.style.transform = 'scale(1)';
                            }
                        };
                    }
                }, 100);
            }

            openMysteryBag() {
                this.bagOpened = true;
                const bag = document.getElementById('mysteryBag');
                const instructions = document.getElementById('bagInstructions');
                
                if (!bag) return;
                
                // Hide instructions and disable click
                instructions.textContent = 'Opening...';
                bag.style.cursor = 'default';
                bag.onclick = null;
                
                // Determine result (50/50 chance)
                const isBonus = Math.random() < 0.5;
                this.bagResult = {
                    isBonus: isBonus,
                    points: isBonus ? 10 : -20,
                    text: isBonus ? 
                        'You found something valuable! +10 Strength Score!' : 
                        'The bag was empty and you wasted time searching. -20 Strength Score!',
                    color: isBonus ? '#22c55e' : '#ef4444',
                    icon: isBonus ? '<img src="Assets/star.png" style="width: 60px; height: 60px; object-fit: contain;" onerror="this.outerHTML=\'‚≠ê\'">' : '<img src="Assets/x.png" style="width: 60px; height: 60px; object-fit: contain;" onerror="this.outerHTML=\'‚ùå\'">'
                };
                
                // Start bag shake animation
                this.animateBagShake(() => {
                    // After shake, show floating result
                    this.showFloatingResult();
                });
            }

            animateBagShake(callback) {
                const bag = document.getElementById('mysteryBag');
                if (!bag) return;
                
                let shakeCount = 0;
                const maxShakes = 6;
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        // Reset position and callback
                        bag.style.transform = 'scale(1.1)'; // Slightly larger to show "open"
                        callback();
                        return;
                    }
                    
                    // Random shake direction
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    
                    bag.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(1.05)`;
                    shakeCount++;
                    
                    setTimeout(shake, 150);
                };
                
                shake();
            }

            showFloatingResult() {
                const result = this.bagResult;
                const animationContainer = document.getElementById('bagResultAnimation');
                const resultDiv = document.getElementById('bagResult');
                const instructions = document.getElementById('bagInstructions');
                
                if (!animationContainer || !resultDiv) return;
                
                // Hide instructions
                instructions.style.display = 'none';
                
                // Create floating icon
                const floatingIcon = document.createElement('div');
                floatingIcon.innerHTML = result.icon;
                floatingIcon.style.fontSize = '60px';
                floatingIcon.style.position = 'absolute';
                floatingIcon.style.left = '50%';
                floatingIcon.style.top = '100%';
                floatingIcon.style.transform = 'translateX(-50%)';
                floatingIcon.style.opacity = '0';
                floatingIcon.style.transition = 'all 1.2s ease-out';
                floatingIcon.style.pointerEvents = 'none';
                floatingIcon.style.zIndex = '10';
                
                animationContainer.appendChild(floatingIcon);
                
                // Animate icon floating up
                setTimeout(() => {
                    floatingIcon.style.opacity = '1';
                    floatingIcon.style.top = '20%';
                    floatingIcon.style.transform = 'translateX(-50%) scale(1.2)';
                }, 100);
                
                // Apply points immediately and show result text
                setTimeout(() => {
                    // Apply the points
                    if (window.gameInstance && window.gameInstance.gameState) {
                        window.gameInstance.gameState.strengthScore += result.points;
                        window.gameInstance.updateGameStats();
                        console.log(`üéí Applied ${result.points} points, new score: ${window.gameInstance.gameState.strengthScore}`);
                    }
                    
                    // Show result text
                    resultDiv.innerHTML = `<span style="color: ${result.color};">${result.text}</span>`;
                    
                    // Show continue button
                    const continueBtn = document.getElementById('bagContinueButton');
                    if (continueBtn) {
                        continueBtn.style.display = 'inline-block';
                        continueBtn.focus();
                        continueBtn.onclick = () => {
                            // Restore default footer for future modals
                            document.getElementById('defaultModalFooter').style.display = 'block';
                            hideModal('squareModal');
                        };
                    }
                }, 800);
                
                // Fade out floating icon
                setTimeout(() => {
                    floatingIcon.style.opacity = '0';
                    floatingIcon.style.transform = 'translateX(-50%) scale(0.8)';
                    setTimeout(() => {
                        if (floatingIcon.parentNode) {
                            floatingIcon.parentNode.removeChild(floatingIcon);
                        }
                    }, 500);
                }, 2000);
            }

            hasBadEventsInTiles(tiles) {
                return tiles.some(tile => this.isBadTile(tile));
            }

            isBadTile(tile) {
                // Check for chutes
                if (tile.square.chute) return true;
                
                // Check for bad square types
                const badTypes = ['battle', 'movement'];
                if (badTypes.includes(tile.square.type)) return true;
                
                // Check for specific harmful subtypes
                if (tile.square.type === 'animation') {
                    // Use position-based deterministic check instead of random
                    const subtype = tile.square.properties?.subtype;
                    if (subtype === 'pickCard' || subtype === 'mysteryBag') {
                        return true; // These can have negative outcomes
                    }
                    return tile.position % 3 === 0; // Every 3rd animation tile is "bad" for consistency
                }
                
                if (tile.square.type === 'random') {
                    return true; // Random is unpredictable, therefore "bad"
                }
                
                return false;
            }

            activatePreventionEffect(tiles) {
                const preventedPositions = tiles.map(t => t.position);
                
                this.addActiveEffect({
                    type: 'prevention',
                    name: 'üõ°Ô∏è Foresight Protection',
                    description: `Prevents bad events on squares ${preventedPositions.join(', ')}`,
                    duration: 10, // Lasts long enough to cover the tiles
                    preventedPositions: preventedPositions
                });
                
                console.log(`üõ°Ô∏è Activated prevention for tiles: ${preventedPositions.join(', ')}`);
            }

            addActiveEffect(effect) {
                this.gameState.activeDebuffs.push({
                    ...effect,
                    id: Date.now() + Math.random(),
                    turnsRemaining: effect.duration || 3
                });
                this.updateDebuffsDisplay();
            }

            hasActivePrevention(position) {
                return this.gameState.activeDebuffs.some(effect => 
                    effect.type === 'prevention' && 
                    effect.preventedPositions && 
                    effect.preventedPositions.includes(position)
                );
            }

            consumePrevention(position) {
                // Remove the specific position from prevention effects
                this.gameState.activeDebuffs.forEach(effect => {
                    if (effect.type === 'prevention' && effect.preventedPositions) {
                        const index = effect.preventedPositions.indexOf(position);
                        if (index > -1) {
                            effect.preventedPositions.splice(index, 1);
                            console.log(`üõ°Ô∏è Consumed prevention for position ${position}`);
                            
                            // If no more positions to protect, remove the effect
                            if (effect.preventedPositions.length === 0) {
                                effect.turnsRemaining = 0; // Will be cleaned up in next processDebuffs
                            } else {
                                // Update description to reflect remaining positions
                                effect.description = `Prevents bad events on squares ${effect.preventedPositions.join(', ')}`;
                            }
                        }
                    }
                });
                
                this.updateDebuffsDisplay();
            }

            isBadMovement(result) {
                // Check if the movement action is harmful (moving backwards)
                return result.movementAction && result.movementAction.type === 'moveBack';
            }
            
            showTemporaryMessage(message) {
                // Create a temporary message overlay
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 1rem 2rem;
                    border-radius: 8px;
                    font-size: 1rem;
                    z-index: 1000;
                    pointer-events: none;
                    animation: fadeInOut 2s ease-in-out;
                `;
                messageDiv.textContent = message;
                document.body.appendChild(messageDiv);
                
                // Remove after animation
                setTimeout(() => {
                    if (messageDiv.parentNode) {
                        messageDiv.parentNode.removeChild(messageDiv);
                    }
                }, 2000);
            }
            
            inspectSquare(squareElement) {
                const position = parseInt(squareElement.dataset.position);
                const square = this.gameState.board.squares[position - 1];
                
                this.showSquareEffect(`Square ${position}`, `
                    <div>
                        <strong>Type:</strong> ${square.type}<br>
                        <strong>Description:</strong> ${this.squareSystem.getSquareDescription(square)}
                        ${square.ladder ? `<br><strong>Ladder to:</strong> ${square.ladder.end}` : ''}
                        ${square.chute ? `<br><strong>Chute to:</strong> ${square.chute.end}` : ''}
                    </div>
                `);
            }
            
            gameWon() {
                this.gameState.isPlaying = false;
                const finalTime = this.gameState.gameTime;
                const finalScore = this.scoreSystem.calculateFinalScore(this.gameState);
                
                document.getElementById('gameOverTitle').textContent = 'üéâ Victory!';
                document.getElementById('gameOverContent').innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; margin-bottom: 1rem; color: var(--success-color);">
                            Congratulations!
                        </div>
                        <div style="margin-bottom: 1rem;">
                            You reached the finish line in <strong>${this.gameState.turn}</strong> turns!
                        </div>
                        <div style="background: var(--light-color); padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                            <div><strong>Final Time:</strong> ${Math.floor(finalTime/60000)}:${Math.floor((finalTime%60000)/1000).toString().padStart(2,'0')}</div>
                            <div><strong>Strength Score:</strong> ${this.gameState.strengthScore}</div>
                            <div><strong>Total Score:</strong> ${finalScore}</div>
                        </div>
                    </div>
                `;
                showModal('gameOverModal');
                
                this.scoreSystem.saveScore(finalScore, this.personas, this.gameState);
            }
            
            gameOver(reason) {
                this.gameState.isPlaying = false;
                
                document.getElementById('gameOverTitle').textContent = 'üíÄ Game Over';
                document.getElementById('gameOverContent').innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 1.5rem; margin-bottom: 1rem; color: var(--danger-color);">
                            ${reason}
                        </div>
                        <div style="margin-bottom: 1rem;">
                            You survived <strong>${this.gameState.turn}</strong> turns and reached square <strong>${this.gameState.currentPosition}</strong>.
                        </div>
                        <div style="background: var(--light-color); padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                            <div><strong>Time Survived:</strong> ${Math.floor(this.gameState.gameTime/60000)}:${Math.floor((this.gameState.gameTime%60000)/1000).toString().padStart(2,'0')}</div>
                            <div><strong>Final Strength:</strong> ${this.gameState.strengthScore}</div>
                        </div>
                    </div>
                `;
                showModal('gameOverModal');
            }
            
            loadSavedData() {
                // Load high scores and settings from localStorage
                const savedScores = localStorage.getItem('boardbreaker_scores');
                if (savedScores) {
                    this.highScores = JSON.parse(savedScores);
                } else {
                    this.highScores = [];
                }
            }
        }
        
        // ===== BOARD GENERATOR CLASS =====
        
        class BoardGenerator {
            constructor() {
                this.squareTypes = [
                    'safe', 'animation', 'movement', 
                    'battle', 'random', 'persona'
                ];
            }
            
            generateBoard(personas) {
                console.log('Generating board for persona:', personas);
                
                const board = {
                    squares: [],
                    ladders: [],
                    chutes: [],
                    personaKey: `${personas.personality}-${personas.playstyle}-${personas.movement}`
                };
                
                // Initialize all squares as safe
                for (let i = 0; i < 50; i++) {
                    board.squares.push({
                        position: i + 1,
                        type: 'safe',
                        properties: {}
                    });
                }
                
                // Generate ladders and chutes based on persona
                this.generateLaddersAndChutes(board, personas);
                
                // Assign special square types
                this.assignSquareTypes(board, personas);
                
                console.log('‚úÖ Board generated:', board);
                return board;
            }
            
            generateLaddersAndChutes(board, personas) {
                console.log('ü™ú Generating ladders and chutes with STRICT BOARD BOUNDARIES...');
                console.log('üìã Persona traits:', personas);
                
                // Display board layout for debugging
                this.displayBoardChart();
                
                // Generate ladders first (4 ladders always) - MUST be first to avoid conflicts
                this.generateLadders(board, personas);
                console.log('ü™ú Ladders generated, now generating chutes to avoid ladder conflicts...');
                
                // Generate chutes (4-7 chutes with persona adjustment) - AFTER ladders to avoid conflicts
                this.generateChutes(board, personas);
                
                console.log(`‚úÖ Generated ${board.ladders.length} ladders and ${board.chutes.length} chutes`);
                this.validateAllPlacements(board);
            }
            
            displayBoardChart() {
                console.log(`
üéØ BOARD LAYOUT (10x5 = 50 squares):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 41 42 43 44 45 46 47 48 49 50 ‚îÇ Row 5 (TOP)       ‚îÇ
‚îÇ 40 39 38 37 36 35 34 33 32 31 ‚îÇ Row 4 (ZIGZAG)    ‚îÇ
‚îÇ 21 22 23 24 25 26 27 28 29 30 ‚îÇ Row 3             ‚îÇ
‚îÇ 20 19 18 17 16 15 14 13 12 11 ‚îÇ Row 2 (ZIGZAG)    ‚îÇ
‚îÇ  1  2  3  4  5  6  7  8  9 10 ‚îÇ Row 1 (BOTTOM)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

ü™ú LADDER RULES:
- START: Squares 4-45 (not on start square 1, finish square 50, or near finish)
- END: Squares 10-49 (not on finish square 50)
- LENGTH: 5-15 tiles forward only

üõù CHUTE RULES:  
- START: Squares 8-47 (not too close to start or finish)
- END: Squares 2-42 (not on start square 1, not too close to finish)
- LENGTH: 6-12 tiles backward only
                `);
            }
            
            validateAllPlacements(board) {
                console.log('üîç VALIDATING ALL PLACEMENTS:');
                
                // Validate ladders
                board.ladders.forEach((ladder, index) => {
                    const valid = this.isPositionOnBoard(ladder.start) && this.isPositionOnBoard(ladder.end);
                    console.log(`ü™ú Ladder ${index + 1}: ${ladder.start} ‚Üí ${ladder.end} - ${valid ? '‚úÖ VALID' : '‚ùå INVALID'}`);
                });
                
                // Validate chutes  
                board.chutes.forEach((chute, index) => {
                    const valid = this.isPositionOnBoard(chute.start) && this.isPositionOnBoard(chute.end);
                    console.log(`üõù Chute ${index + 1}: ${chute.start} ‚Üí ${chute.end} - ${valid ? '‚úÖ VALID' : '‚ùå INVALID'}`);
                });
            }
            
            isPositionOnBoard(position) {
                return position >= 1 && position <= 50 && Number.isInteger(position);
            }
            
            generateLadders(board, personas) {
                // Fixed ladder count: exactly 4 ladders
                let ladderCount = 4;
                
                console.log(`üéØ Generating ${ladderCount} ladders for balanced gameplay`);
                const placedLadders = [];
                
                for (let i = 0; i < ladderCount; i++) {
                    let attempts = 0;
                    let ladder = null;
                    
                    while (attempts < 200 && !ladder) {
                        const candidateLadder = this.generateLadder(board, personas, placedLadders, attempts);
                        
                        // Skip if generateLadder returned null (couldn't create valid ladder)
                        if (!candidateLadder) {
                            attempts++;
                            continue;
                        }
                        
                        if (this.isValidLadder(board, candidateLadder, placedLadders)) {
                            // Final safety check: ensure ladder length is at least 6 squares
                            const finalLength = candidateLadder.end - candidateLadder.start;
                            if (finalLength >= 6) {
                                ladder = candidateLadder;
                                placedLadders.push(ladder);
                                
                                // Add to board
                                board.ladders.push({ start: ladder.start, end: ladder.end });
                                board.squares[ladder.start - 1].ladder = { end: ladder.end };
                                
                                console.log(`ü™ú Ladder ${i+1}: ${ladder.start} ‚Üí ${ladder.end} (${ladder.end - ladder.start} tiles, ${this.getLadderDirection(ladder.start, ladder.end)})`);
                            } else {
                                console.warn(`üõë Rejected short ladder candidate: ${candidateLadder.start} ‚Üí ${candidateLadder.end} (length: ${finalLength})`);
                            }
                        }
                        attempts++;
                    }
                    
                    if (!ladder) {
                        console.warn(`‚ö†Ô∏è Could not place ladder ${i+1} after ${attempts} attempts`);
                    }
                }
            }
            
            generateChutes(board, personas) {
                // Fixed chute count: exactly 4 chutes
                let chuteCount = 4;
                
                console.log(`üéØ Generating ${chuteCount} chutes for BALANCED gameplay (reduced from previous system)`);
                
                const placedChutes = [];
                
                for (let i = 0; i < chuteCount; i++) {
                    let attempts = 0;
                    let chute = null;
                    
                    while (attempts < 200 && !chute) {
                        const candidateChute = this.generateChute(board, personas, placedChutes, attempts);
                        
                        // Skip if generateChute returned null (couldn't create valid chute)
                        if (!candidateChute) {
                            attempts++;
                            continue;
                        }
                        
                        if (this.isValidChute(board, candidateChute, placedChutes)) {
                            // Final safety check: ensure chute length is at least 6 squares
                            const finalLength = candidateChute.start - candidateChute.end;
                            if (finalLength >= 6) {
                                chute = candidateChute;
                                placedChutes.push(chute);
                                
                                // Add to board
                                board.chutes.push({ start: chute.start, end: chute.end });
                                board.squares[chute.start - 1].chute = { end: chute.end };
                                
                                console.log(`üõù Chute ${i+1}: ${chute.start} ‚Üí ${chute.end} (${chute.start - chute.end} tiles, ${this.getLadderDirection(chute.start, chute.end)})`);
                            } else {
                                console.warn(`üõë Rejected short chute candidate: ${candidateChute.start} ‚Üí ${candidateChute.end} (length: ${finalLength})`);
                            }
                        }
                        attempts++;
                    }
                    
                    if (!chute) {
                        console.warn(`‚ö†Ô∏è Could not place chute ${i+1} after ${attempts} attempts - may be due to ladder conflicts or spacing issues`);
                    }
                }
            }

            isValidLadder(board, ladder, placedLadders) {
                const { start, end } = ladder;
                
                // STRICT LADDER VALIDATION - SAME CONSTANTS AS GENERATION
                const LADDER_MIN_START = 4;
                const LADDER_MAX_START = 45;
                const LADDER_MIN_END = 10;
                const LADDER_MAX_END = 49;
                const LADDER_MIN_LENGTH = 5;
                const LADDER_MAX_LENGTH = 15;
                
                console.log(`üîç Validating ladder: ${start} ‚Üí ${end} (length: ${end - start})`);
                
                // Rule: CRITICAL - Both start and end must be within game board (1-50)
                if (start < 1 || start > 50 || !Number.isInteger(start)) {
                    console.log(`‚ùå Ladder start ${start} is outside game board (1-50) or not integer`);
                    return false;
                }
                if (end < 1 || end > 50 || !Number.isInteger(end)) {
                    console.log(`‚ùå Ladder end ${end} is outside game board (1-50) or not integer`);
                    return false;
                }
                
                // Rule: Start must be in valid range
                if (start < LADDER_MIN_START || start > LADDER_MAX_START) {
                    console.log(`‚ùå Ladder start ${start} outside valid range (${LADDER_MIN_START}-${LADDER_MAX_START})`);
                    return false;
                }
                
                // Rule: End must be in valid range 
                if (end < LADDER_MIN_END || end > LADDER_MAX_END) {
                    console.log(`‚ùå Ladder end ${end} outside valid range (${LADDER_MIN_END}-${LADDER_MAX_END})`);
                    return false;
                }
                
                // Rule: Length must be valid
                const length = end - start;
                if (length < LADDER_MIN_LENGTH || length > LADDER_MAX_LENGTH) {
                    console.log(`‚ùå Ladder length ${length} outside valid range (${LADDER_MIN_LENGTH}-${LADDER_MAX_LENGTH})`);
                    return false;
                }
                
                // Rule: Cannot start or end on a chute square
                if (board.squares[start - 1].chute || board.squares[end - 1].chute) return false;
                
                // Rule: Cannot overlap existing ladders
                if (board.squares[start - 1].ladder || board.squares[end - 1].ladder) return false;
                
                // Rule: Ladder starts cannot be back-to-back
                for (const existing of placedLadders) {
                    if (Math.abs(start - existing.start) === 1) return false;
                    if (Math.abs(start - existing.end) === 1) return false;
                    if (Math.abs(end - existing.start) === 1) return false;
                }
                
                return true;
            }
            
            isValidChute(board, chute, placedChutes) {
                const { start, end } = chute;
                
                // STRICT CHUTE VALIDATION - SAME CONSTANTS AS GENERATION  
                const CHUTE_MIN_START = 8;
                const CHUTE_MAX_START = 47;
                const CHUTE_MIN_END = 2;
                const CHUTE_MAX_END = 42;
                const CHUTE_MIN_LENGTH = 6;
                const CHUTE_MAX_LENGTH = 12;
                
                console.log(`üîç Validating chute: ${start} ‚Üí ${end} (length: ${start - end})`);
                
                // Rule: CRITICAL - Both start and end must be within game board (1-50)
                if (start < 1 || start > 50 || !Number.isInteger(start)) {
                    console.log(`‚ùå Chute start ${start} is outside game board (1-50) or not integer`);
                    return false;
                }
                if (end < 1 || end > 50 || !Number.isInteger(end)) {
                    console.log(`‚ùå Chute end ${end} is outside game board (1-50) or not integer`);
                    return false;
                }
                
                // Rule: Start must be in valid range
                if (start < CHUTE_MIN_START || start > CHUTE_MAX_START) {
                    console.log(`‚ùå Chute start ${start} outside valid range (${CHUTE_MIN_START}-${CHUTE_MAX_START})`);
                    return false;
                }
                
                // Rule: End must be in valid range
                if (end < CHUTE_MIN_END || end > CHUTE_MAX_END) {
                    console.log(`‚ùå Chute end ${end} outside valid range (${CHUTE_MIN_END}-${CHUTE_MAX_END})`);
                    return false;
                }
                
                // Rule: Length must be valid (chutes go backward, so start - end)
                const length = start - end;
                if (length < CHUTE_MIN_LENGTH || length > CHUTE_MAX_LENGTH) {
                    console.log(`‚ùå Chute length ${length} outside valid range (${CHUTE_MIN_LENGTH}-${CHUTE_MAX_LENGTH})`);
                    return false;
                }
                
                // Rule: Cannot start within 3 tiles of another chute start (better spacing)
                for (const existing of placedChutes) {
                    if (Math.abs(start - existing.start) <= 3) return false;
                }
                
                // Rule: CRITICAL - Cannot overlap with ladders at start OR end positions
                if (board.squares[start - 1].ladder) {
                    console.log(`‚ùå Chute start ${start} conflicts with existing ladder`);
                    return false;
                }
                if (board.squares[end - 1].ladder) {
                    console.log(`‚ùå Chute end ${end} conflicts with existing ladder`);
                    return false;
                }
                
                // Rule: Cannot overlap with other chutes
                if (board.squares[start - 1].chute || board.squares[end - 1].chute) return false;
                
                console.log(`‚úÖ Valid chute: ${start} ‚Üí ${end} (${start - end} tiles)`);
                return true;
            }
            
            generateLadder(board, personas, placedLadders, attempt) {
                console.log(`üîß Generating 3-row diagonal ladder attempt ${attempt + 1}...`);
                
                // Priority: Generate ladders that span EXACTLY 3 rows for better visual impact
                const PREFERRED_3ROW_SPANS = [
                    // Row 1 ‚Üí Row 4 (3 rows): positions 1-10 ‚Üí 31-40
                    { startRange: [4, 8], endRange: [32, 38] },    // Safe middle positions
                    // Row 2 ‚Üí Row 5 (3 rows): positions 11-20 ‚Üí 41-49  
                    { startRange: [12, 18], endRange: [42, 47] },   // Safe positions avoiding finish
                ];
                
                // 70% chance to try 3-row diagonal, 30% chance for shorter
                const prefer3Row = Math.random() < 0.7;
                
                let start, end;
                
                if (prefer3Row && PREFERRED_3ROW_SPANS.length > 0) {
                    // Try to generate a 3-row diagonal ladder
                    const span = PREFERRED_3ROW_SPANS[Math.floor(Math.random() * PREFERRED_3ROW_SPANS.length)];
                    start = span.startRange[0] + Math.floor(Math.random() * (span.startRange[1] - span.startRange[0] + 1));
                    end = span.endRange[0] + Math.floor(Math.random() * (span.endRange[1] - span.endRange[0] + 1));
                    
                    console.log(`üéØ Attempting 3-row diagonal ladder: ${start} ‚Üí ${end}`);
                } else {
                    // Generate regular ladder with standard rules
                    const LADDER_MIN_START = 4;
                    const LADDER_MAX_START = 42;  // Reduced to ensure valid ends
                    const LADDER_MIN_END = 15;
                    const LADDER_MAX_END = 49;
                    
                    start = LADDER_MIN_START + Math.floor(Math.random() * (LADDER_MAX_START - LADDER_MIN_START + 1));
                    
                    // Ensure minimum advancement of 8 squares for good ladders
                    const minAdvancement = 8;
                    const maxAdvancement = Math.min(18, LADDER_MAX_END - start);
                    
                    if (maxAdvancement < minAdvancement) {
                        console.log(`‚ùå Cannot create valid ladder from start ${start}`);
                        return null;
                    }
                    
                    const advancement = minAdvancement + Math.floor(Math.random() * (maxAdvancement - minAdvancement + 1));
                    end = start + advancement;
                    
                    console.log(`ü™ú Regular ladder: ${start} ‚Üí ${end} (${advancement} squares)`);
                }
                
                // Validate bounds
                if (start < 1 || start > 50 || end < 1 || end > 50 || start >= end) {
                    console.log(`‚ùå Invalid ladder bounds: ${start} ‚Üí ${end}`);
                    return null;
                }
                
                // Validate it's actually a good advancement
                const length = end - start;
                if (length < 6) {  // Minimum meaningful ladder
                    console.log(`‚ùå Ladder too short: ${length} squares`);
                    return null;
                }
                
                console.log(`‚úÖ Generated ladder: ${start} ‚Üí ${end} (${length} squares)`);
                return { start, end, length };
            }
            
            generateChute(board, personas, placedChutes, attempt) {
                console.log(`üîß Generating 3-row diagonal chute attempt ${attempt + 1}...`);
                
                // Priority: Generate chutes that span EXACTLY 3 rows for better visual impact
                const PREFERRED_3ROW_SLIDES = [
                    // Row 4 ‚Üí Row 1 (3 rows down): positions 31-40 ‚Üí 1-10
                    { startRange: [33, 37], endRange: [3, 7] },     // Safe middle positions
                    // Row 5 ‚Üí Row 2 (3 rows down): positions 41-49 ‚Üí 11-20
                    { startRange: [42, 46], endRange: [12, 16] },   // Safe positions avoiding start
                    // Row 3 ‚Üí Row 1 (2 rows down): positions 21-30 ‚Üí 1-10  
                    { startRange: [23, 27], endRange: [4, 8] },     // Shorter but still good
                ];
                
                // 70% chance to try 3-row diagonal, 30% chance for shorter
                const prefer3Row = Math.random() < 0.7;
                
                let start, end;
                
                if (prefer3Row && PREFERRED_3ROW_SLIDES.length > 0) {
                    // Try to generate a 3-row diagonal chute
                    const slide = PREFERRED_3ROW_SLIDES[Math.floor(Math.random() * PREFERRED_3ROW_SLIDES.length)];
                    start = slide.startRange[0] + Math.floor(Math.random() * (slide.startRange[1] - slide.startRange[0] + 1));
                    end = slide.endRange[0] + Math.floor(Math.random() * (slide.endRange[1] - slide.endRange[0] + 1));
                    
                    console.log(`üéØ Attempting 3-row diagonal chute: ${start} ‚Üí ${end}`);
                } else {
                    // Generate regular chute with standard rules
                    const CHUTE_MIN_START = 15;   // Must start high enough
                    const CHUTE_MAX_START = 45;   // Cannot start too close to finish
                    const CHUTE_MIN_END = 3;      // Cannot end too close to start
                    const CHUTE_MAX_END = 35;     // Cannot end too high
                    
                    start = CHUTE_MIN_START + Math.floor(Math.random() * (CHUTE_MAX_START - CHUTE_MIN_START + 1));
                    
                    // Ensure minimum slide of 8 squares for meaningful punishment
                    const minSlide = 8;
                    const maxSlide = Math.min(15, start - CHUTE_MIN_END);
                    
                    if (maxSlide < minSlide) {
                        console.log(`‚ùå Cannot create valid chute from start ${start}`);
                        return null;
                    }
                    
                    const slide = minSlide + Math.floor(Math.random() * (maxSlide - minSlide + 1));
                    end = start - slide;
                    
                    console.log(`üõù Regular chute: ${start} ‚Üí ${end} (${slide} squares back)`);
                }
                
                // Validate bounds
                if (start < 1 || start > 50 || end < 1 || end > 50 || start <= end) {
                    console.log(`‚ùå Invalid chute bounds: ${start} ‚Üí ${end}`);
                    return null;
                }
                
                // Validate it's actually a meaningful punishment
                const length = start - end;
                if (length < 6) {  // Minimum meaningful chute
                    console.log(`‚ùå Chute too short: ${length} squares`);
                    return null;
                }
                
                console.log(`‚úÖ Generated chute: ${start} ‚Üí ${end} (${length} squares back)`);
                return { start, end, length };
            }
            
            getPersonaLadderLength(personas, attempt) {
                const base = 8;
                
                if (personas.personality === 'daredevil' || personas.playstyle === 'lucky') {
                    // Daredevil/Lucky: Sometimes absurdly long ladders (slingshot effect)
                    return Math.random() < 0.3 ? 25 : base + Math.floor(Math.random() * 8);
                } else if (personas.personality === 'tactician' || personas.movement === 'sprinter') {
                    // Tactician/Sprinter: More reliable, consistent lengths
                    return base + Math.floor(Math.random() * 4);
                } else {
                    // Default range
                    return base + Math.floor(Math.random() * 6);
                }
            }
            
            getPersonaChuteLength(personas, attempt) {
                // Balanced chute lengths: 6-12 tiles (reasonable punishment, not too extreme)
                const minLength = 6;  // Minimum meaningful chute
                const maxLength = 12; // Maximum reasonable chute
                
                if (personas.personality === 'tactician' || personas.playstyle === 'lucky') {
                    // Tactician/Lucky: Shorter, more recoverable chutes (6-9 tiles)
                    return minLength + Math.floor(Math.random() * 4);
                } else if (personas.personality === 'daredevil' || personas.movement === 'persistent') {
                    // Daredevil/Persistent: Longer chutes for higher stakes (8-12 tiles)
                    return 8 + Math.floor(Math.random() * 5);
                } else {
                    // Default balanced range (7-11 tiles)
                    return 7 + Math.floor(Math.random() * 5);
                }
            }

            // Legacy method - redirects to new implementation  
            getLadderLength(personas, attempt) {
                return this.getPersonaLadderLength(personas, attempt);
            }
            
            assignSquareTypes(board, personas) {
                const availableSquares = [];
                
                // Find squares without ladders/chutes
                for (let i = 0; i < 50; i++) {
                    if (i !== 0 && i !== 49 && // Not start or finish
                        !board.squares[i].ladder && 
                        !board.squares[i].chute) {
                        availableSquares.push(i);
                    }
                }
                
                // Shuffle available squares
                this.shuffleArray(availableSquares);
                
                let typeIndex = 0;
                
                // GUARANTEED: Each mini-game appears exactly twice
                console.log('üéÆ Placing guaranteed mini-games (2 each)...');
                
                // Place 2 Collect Star battles
                for (let i = 0; i < 2 && typeIndex < availableSquares.length; i++) {
                    const squareIndex = availableSquares[typeIndex];
                    board.squares[squareIndex].type = 'battle';
                    board.squares[squareIndex].properties = {
                        subtype: 'dodgeDrop',
                        difficulty: personas.playstyle === 'lucky' ? 'easy' : 'normal'
                    };
                    console.log(`‚≠ê Placed Collect Star at square ${squareIndex + 1}`);
                    typeIndex++;
                }
                
                // Place 2 Balloon Burst movements
                for (let i = 0; i < 2 && typeIndex < availableSquares.length; i++) {
                    const squareIndex = availableSquares[typeIndex];
                    board.squares[squareIndex].type = 'movement';
                    board.squares[squareIndex].properties = {
                        subtype: 'balloonBurst'
                    };
                    console.log(`üéà Placed Balloon Burst at square ${squareIndex + 1}`);
                    typeIndex++;
                }
                
                // Place 2 Color Sequence battles
                for (let i = 0; i < 2 && typeIndex < availableSquares.length; i++) {
                    const squareIndex = availableSquares[typeIndex];
                    board.squares[squareIndex].type = 'battle';
                    board.squares[squareIndex].properties = {
                        subtype: 'colorSequence',
                        difficulty: personas.playstyle === 'lucky' ? 'easy' : 'normal'
                    };
                    console.log(`üåà Placed Color Sequence at square ${squareIndex + 1}`);
                    typeIndex++;
                }
                
                // Fill remaining squares with other types
                const remainingTypeDistribution = this.getRemainingTypeDistribution(personas);
                
                Object.entries(remainingTypeDistribution).forEach(([type, count]) => {
                    for (let i = 0; i < count && typeIndex < availableSquares.length; i++) {
                        const squareIndex = availableSquares[typeIndex];
                        board.squares[squareIndex].type = type;
                        board.squares[squareIndex].properties = this.generateSquareProperties(type, personas);
                        typeIndex++;
                    }
                });
                
                console.log(`üéÆ Mini-game placement complete. ${typeIndex} squares assigned out of ${availableSquares.length} available.`);
            }
            
            getTypeDistribution(personas) {
                const base = {
                    safe: 10, // Increased to replace targeted squares
                    animation: 6,
                    movement: 5,
                    battle: 6,
                    random: 3,
                    persona: 3
                };
                
                // Adjust based on persona
                if (personas.playstyle === 'lucky') {
                    base.safe += 2; // More bonus squares
                    base.battle -= 1;
                } else if (personas.playstyle === 'persistent') {
                    base.battle += 2; // More obstacles
                    base.safe -= 1;
                }
                
                if (personas.personality === 'daredevil') {
                    base.battle += 1;
                    base.random += 1;
                    base.safe -= 2;
                }
                
                return base;
            }
            
            getRemainingTypeDistribution(personas) {
                // We've already placed 6 squares (2 of each mini-game):
                // - 2 battle squares (Dodge Star) 
                // - 2 movement squares (Balloon Burst)
                // - 2 battle squares (Color Sequence)
                // Total: 4 battle, 2 movement already placed
                
                const base = {
                    safe: 10, // Increased to replace targeted squares
                    animation: 6,
                    movement: 0, // No more movement squares needed (we placed 2 balloon burst)
                    battle: 0, // No more battle squares needed (we placed 4 total)
                    random: 3,
                    persona: 3
                };
                
                // Adjust based on persona
                if (personas.playstyle === 'lucky') {
                    base.safe += 2; // More bonus squares
                } else if (personas.playstyle === 'persistent') {
                    base.safe -= 1; // Fewer safe squares for persistent players
                }
                
                if (personas.personality === 'daredevil') {
                    base.random += 1;
                    base.safe -= 2;
                }
                
                // Ensure we don't have negative values
                Object.keys(base).forEach(key => {
                    if (base[key] < 0) base[key] = 0;
                });
                
                console.log('üìä Remaining type distribution:', base);
                return base;
            }
            
            generateSquareProperties(type, personas) {
                const properties = {};
                
                switch (type) {
                    case 'animation':
                        properties.subtype = this.randomChoice(['pickCard', 'spinToken', 'mysteryBag']);
                        break;
                    case 'movement':
                        properties.subtype = 'balloonBurst'; // Only balloon burst mini-game
                        break;
                    case 'battle':
                        // Exclude mini-games since they're placed separately
                        properties.subtype = this.randomChoice(['tapRace', 'quickAim', 'memoryMatch']);
                        properties.difficulty = personas.playstyle === 'lucky' ? 'easy' : 'normal';
                        break;
                    case 'persona':
                        properties.targetTrait = this.randomChoice([personas.personality, personas.playstyle, personas.movement]);
                        break;
                }
                
                return properties;
            }
            
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            randomChoice(array) {
                return array[Math.floor(Math.random() * array.length)];
            }
            
            getLadderDirection(start, end) {
                // CORRECT 10√ó5 board layout calculations
                const startIndex = start - 1; // Convert to 0-based index
                const endIndex = end - 1;
                
                // Calculate row and column for 10√ó5 zigzag board
                const startRow = Math.floor(startIndex / 10);
                const endRow = Math.floor(endIndex / 10);
                
                // Calculate column based on zigzag pattern
                let startCol, endCol;
                if (startRow % 2 === 0) {
                    // Even rows: left to right
                    startCol = startIndex % 10;
                } else {
                    // Odd rows: right to left (zigzag)
                    startCol = 9 - (startIndex % 10);
                }
                
                if (endRow % 2 === 0) {
                    // Even rows: left to right
                    endCol = endIndex % 10;
                } else {
                    // Odd rows: right to left (zigzag)
                    endCol = 9 - (endIndex % 10);
                }
                
                const rowDiff = Math.abs(endRow - startRow);
                const colDiff = Math.abs(endCol - startCol);
                
                // Determine direction based on row/column differences
                if (rowDiff === 0) return 'horizontal';
                if (colDiff === 0) return 'vertical';
                
                // For diagonal: prioritize spanning 3 rows when possible
                if (rowDiff >= 3) return 'diagonal-3row';
                return 'diagonal';
            }
        }
        
        // ===== SQUARE SYSTEM CLASS =====
        
        class SquareSystem {
            constructor() {
                this.squareHandlers = {
                    safe: this.handleSafeSquare.bind(this),
                    animation: this.handleAnimationSquare.bind(this),
                    movement: this.handleMovementSquare.bind(this),
                    battle: this.handleBattleSquare.bind(this),
                    random: this.handleRandomSquare.bind(this),
                    persona: this.handlePersonaSquare.bind(this)
                };
            }
            
            async resolveSquare(square, gameState, personas, gameInstance = null) {
                console.log(`Resolving square ${square.position} of type ${square.type}`);
                
                const handler = this.squareHandlers[square.type];
                if (handler) {
                    return await handler(square, gameState, personas, gameInstance);
                } else {
                    return { showEffect: false };
                }
            }
            
            async handleSafeSquare(square, gameState, personas) {
                const safeTypes = ['rest', 'viewAhead', 'freebie'];
                const subtype = square.properties.subtype || this.randomChoice(safeTypes);
                
                switch (subtype) {
                    case 'rest':
                        return {
                            showEffect: true,
                            title: 'üò¥ Safe Rest',
                            message: 'You take a moment to rest. Nothing happens.',
                            customAnimation: 'starfall'  // Flag for custom animation
                        };
                    case 'viewAhead':
                        return {
                            showEffect: true,
                            title: 'üëÄ View Ahead',
                            message: 'You scout the path ahead and see what\'s coming next!',
                            customAnimation: 'viewAhead'  // Flag for custom animation
                        };
                    case 'freebie':
                        // Check if there are active debuffs and prepare message
                        const hasDebuffs = gameState.activeDebuffs.length > 0;
                        const message = hasDebuffs ? 
                            'Any debuffs? A mysterious force will remove them for you and give you 10 points!' :
                            'A magical fairy grants you 10 bonus points!';
                        
                            return {
                                showEffect: true,
                            title: '<img src="Assets/star.png" style="width: 20px; height: 20px; object-fit: contain; vertical-align: middle;" onerror="this.outerHTML=\'‚ú®\'"> Freebie',
                            message: message,
                            customAnimation: 'fairy'  // Flag for custom animation
                        };
                }
            }
            
            async handleAnimationSquare(square, gameState, personas) {
                const subtype = square.properties.subtype || 'pickCard';
                
                switch (subtype) {
                    case 'pickCard':
                            return {
                                showEffect: true,
                            title: 'üÉè Pick a Card',
                            message: 'Pick one card - but escape the penalty one comes with.',
                            customAnimation: 'pickCard'  // Flag for custom animation
                        };
                    case 'spinToken':
                            return {
                                showEffect: true,
                            title: 'üé∞ Spin Token',
                            message: 'The token spins you 2 spaces forward/backward!',
                            customAnimation: 'spinToken'  // Flag for custom animation
                        };
                    case 'mysteryBag':
                            return {
                                showEffect: true,
                            title: '<img src="Assets/backpack.png" style="width: 20px; height: 20px; object-fit: contain; vertical-align: middle;" onerror="this.outerHTML=\'üéí\'"> Mystery Bag',
                            message: 'Click the bag to see what\'s inside!',
                            customAnimation: 'mysteryBag'  // Flag for custom animation
                        };
                }
            }
            
            async handleMovementSquare(square, gameState, personas) {
                const subtype = square.properties.subtype || 'moveBack';
                const distance = square.properties.distance || 3;
                
                console.log(`üîß HandleMovementSquare - subtype: ${subtype}, distance: ${distance}, current position: ${gameState.currentPosition}`);
                
                switch (subtype) {
                    case 'moveBack':
                        const newPos = Math.max(1, gameState.currentPosition - distance); // Don't go below square 1
                        console.log(`‚¨ÖÔ∏è Creating backwards movement: from ${gameState.currentPosition} to ${newPos}`);
                        return {
                            showEffect: true,
                            title: '‚¨ÖÔ∏è Move Backward',
                            message: `You are pushed back ${distance} spaces to square ${newPos}!`,
                            movementAction: {
                                type: 'moveBack',
                                from: gameState.currentPosition,
                                to: newPos,
                                distance: distance
                            }
                        };
                    case 'moveForward':
                        const forwardPos = Math.min(50, gameState.currentPosition + distance);
                        return {
                            showEffect: true,
                            title: '‚û°Ô∏è Move Forward',
                            message: `You are pushed forward ${distance} spaces to square ${forwardPos}!`,
                            movementAction: {
                                type: 'moveForward',
                                from: gameState.currentPosition,
                                to: forwardPos,
                                distance: distance
                            }
                        };
                    case 'balloonBurst':
                        return {
                            showEffect: true,
                            title: 'üéà Balloon Burst Challenge',
                            message: 'Pop balloons with SPACEBAR in 7 seconds! Avoid spiked balloons!',
                            customAnimation: 'balloonBurst',  // Flag for custom mini-game
                            personas: personas  // Pass personas for difficulty
                        };
                    default:
                        return {
                            showEffect: true,
                            title: 'Movement Effect',
                            message: 'Something affects your movement!'
                        };
                }
            }
            
            async handleBattleSquare(square, gameState, personas) {
                const subtype = square.properties.subtype || 'tapRace';
                
                switch (subtype) {
                    case 'tapRace':
                        return {
                            showEffect: true,
                            title: '‚öîÔ∏è Tap Race Challenge',
                            message: 'Tap as fast as you can for 5 seconds!',
                            customAnimation: 'tapRace',  // Flag for custom mini-game
                            personas: personas  // Pass personas for risk calculation
                        };
                    case 'quickAim':
                        return {
                            showEffect: true,
                            title: 'üèπ Quick Aim Challenge',
                            message: 'Shoot 3 arrows at the moving target!',
                            customAnimation: 'quickAim',  // Flag for custom mini-game
                            personas: personas  // Pass personas for potential bonuses
                        };
                    case 'memoryMatch':
                        return {
                            showEffect: true,
                            title: 'üß† Memory Match Challenge',
                            message: 'Test your memory with themed cards!',
                            customAnimation: 'memoryMatch',  // Flag for custom mini-game
                            personas: personas  // Pass personas for themed icons
                        };
                    case 'dodgeDrop':
                        return {
                            showEffect: true,
                            title: '‚≠ê Collect Star Challenge',
                            message: 'Collect falling stars and power-up shields for points!',
                            customAnimation: 'dodgeStar',  // Flag for custom mini-game
                            personas: personas  // Pass personas for difficulty
                        };
                    case 'colorSequence':
                        return {
                            showEffect: true,
                            title: 'üåà Color Sequence Challenge',
                            message: 'Memorize and repeat the color sequence!',
                            customAnimation: 'colorSequence',  // Flag for custom mini-game
                            personas: personas  // Pass personas for difficulty
                        };
                    default:
                        // For other battle types, simulate outcome
                const success = Math.random() > 0.5;
                
                if (success) {
                    gameState.strengthScore += 5;
                    return {
                        showEffect: true,
                                title: `‚öîÔ∏è Battle Won - ${subtype}`,
                        message: 'You won the challenge! +5 Strength Score!'
                    };
                } else {
                    gameState.strengthScore -= 3;
                    return {
                        showEffect: true,
                        title: `üíÄ Battle Lost - ${subtype}`,
                        message: 'You lost the challenge. -3 Strength Score and gain a debuff.',
                        debuff: {
                            type: 'weakened',
                            name: 'Battle Fatigue',
                            description: 'Reduced performance from battle',
                            duration: 2
                        }
                    };
                        }
                }
            }
            
            async handleRandomSquare(square, gameState, personas) {
                // Storm Shift cannot appear within 7 tiles of finish (positions 94-100)
                const availableEvents = [];
                
                if (gameState.currentPosition <= 93) {
                    availableEvents.push('stormShift');
                }
                availableEvents.push('tradePlaces', 'doubleTrouble');
                
                const event = this.randomChoice(availableEvents);
                
                switch (event) {
                    case 'stormShift':
                        return {
                            showEffect: true,
                            title: 'üå©Ô∏è Storm Shift',
                            message: 'A storm reshuffles tiles on the board! Click "Shuffle" to unleash the storm.',
                            customAnimation: 'stormShift'
                        };
                    case 'tradePlaces':
                        return {
                            showEffect: true,
                            title: 'üîÑ Trade Places',
                            message: 'You swap positions with a phantom player!',
                            customAnimation: 'tradePlaces'
                        };
                    case 'doubleTrouble':
                        return {
                            showEffect: true,
                            title: 'üéØ Double Trouble',
                            message: 'Next roll is doubled!',
                            customAnimation: 'doubleTrouble'
                        };
                }
            }
            
            async handlePersonaSquare(square, gameState, personas) {
                    return {
                        showEffect: true,
                    title: 'üß† Memory Match Challenge',
                    message: 'Test your memory with persona-themed cards!',
                    customAnimation: 'memoryMatch',  // Flag for custom mini-game
                    personas: personas  // Pass personas for themed icons
                };
            }
            
            getSquareDescription(square) {
                const descriptions = {
                    safe: 'A safe square with helpful effects',
                    animation: 'Interactive challenge with animations',
                    movement: 'Balloon Burst mini-game challenge',
                    battle: 'Mini-game battle challenge',
                    random: 'Random event that affects the game',
                    persona: 'Challenge specific to your persona traits'
                };
                
                return descriptions[square.type] || 'Unknown square type';
            }
            
            randomChoice(array) {
                return array[Math.floor(Math.random() * array.length)];
            }
        }
        
        // ===== ANIMATION ENGINE CLASS =====
        
        class AnimationEngine {
            constructor() {
                this.isAnimating = false;
            }
            
            // Normal movement follows the zigzag board pattern
            animateNormalMovement(startPosition, endPosition, callback) {
                if (this.isAnimating) return;
                
                this.isAnimating = true;
                const playerElement = document.getElementById('playerPiece');
                playerElement.classList.add('moving');
                
                console.log(`üé≤ Normal movement: ${startPosition} ‚Üí ${endPosition}`);
                
                // If starting from position 0 (off board), show the player piece
                if (startPosition === 0) {
                    playerElement.style.display = 'flex';
                }
                
                // Calculate path following zigzag pattern
                const steps = Math.abs(endPosition - startPosition);
                let currentStep = 0;
                const stepDuration = 300;
                
                const moveStep = () => {
                    if (currentStep >= steps) {
                        playerElement.classList.remove('moving');
                        this.isAnimating = false;
                        if (callback) callback();
                        return;
                    }
                    
                    const currentPos = startPosition < endPosition ? 
                        startPosition + currentStep + 1 : 
                        startPosition - currentStep - 1;
                    
                    // Only animate positions that are on the board (1-50)
                    if (currentPos >= 1 && currentPos <= 50) {
                    const position = this.getSquarePosition(currentPos);
                        playerElement.style.left = `${position.x + 5}px`;
                        playerElement.style.top = `${position.y + 5}px`;
                    }
                    
                    currentStep++;
                    setTimeout(moveStep, stepDuration);
                };
                
                moveStep();
            }
            
            // Special movement for chutes and ladders - follows diagonal lines
            animateSpecialMovement(startPosition, endPosition, movementType, callback) {
                if (this.isAnimating) return;
                
                this.isAnimating = true;
                const playerElement = document.getElementById('playerPiece');
                playerElement.classList.add('moving', 'special-movement');
                
                console.log(`${movementType} Special movement: ${startPosition} ‚Üí ${endPosition}`);
                
                // Get start and end positions
                const startPos = this.getSquarePosition(startPosition);
                const endPos = this.getSquarePosition(endPosition);
                
                // Calculate center points for smooth animation
                const startX = startPos.x + 40; // Center of square (80px/2)
                const startY = startPos.y + 40;
                const endX = endPos.x + 40;
                const endY = endPos.y + 40;
                
                // Animation settings
                const totalDuration = 1200; // ms for complete animation
                const frameRate = 60; // fps
                const totalFrames = (totalDuration / 1000) * frameRate;
                let currentFrame = 0;
                
                const animateFrame = () => {
                    if (currentFrame >= totalFrames) {
                        // Final position
                        playerElement.style.left = `${endPos.x + 5}px`;
                        playerElement.style.top = `${endPos.y + 5}px`;
                        playerElement.classList.remove('moving', 'special-movement');
                        this.isAnimating = false;
                        if (callback) callback();
                        return;
                    }
                    
                    // Calculate current position using smooth easing
                    const progress = currentFrame / totalFrames;
                    const easedProgress = this.easeInOutCubic(progress);
                    
                    const currentX = startX + (endX - startX) * easedProgress;
                    const currentY = startY + (endY - startY) * easedProgress;
                    
                    // Position player element (subtract half size for centering)
                    playerElement.style.left = `${currentX - 35}px`;
                    playerElement.style.top = `${currentY - 35}px`;
                    
                    currentFrame++;
                    requestAnimationFrame(animateFrame);
                };
                
                animateFrame();
            }
            
            // Master animation method that decides movement type
            animatePlayerMovement(startPosition, endPosition, callback, isSpecialMovement = false, movementType = 'üé≤') {
                if (isSpecialMovement) {
                    this.animateSpecialMovement(startPosition, endPosition, movementType, callback);
                } else {
                    this.animateNormalMovement(startPosition, endPosition, callback);
                }
            }
            
            // Smooth easing function
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            getSquarePosition(squareNumber) {
                // Convert square number (1-50) to array index (0-49)
                const index = squareNumber - 1;
                const row = Math.floor(index / 10);
                
                // Calculate column based on row direction
                // Even rows (0, 2, 4): left to right
                // Odd rows (1, 3): right to left (zigzag pattern)
                let col;
                if (row % 2 === 0) {
                    // Even rows: left to right (normal order)
                    col = index % 10;
                } else {
                    // Odd rows: right to left (reverse order)
                    col = 9 - (index % 10);
                }
                
                // Get dynamic square size
                const squareSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--square-size')) || 80;
                const gapSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap-size')) || 2;
                
                return {
                    x: col * (squareSize + gapSize),
                    y: (4 - row) * (squareSize + gapSize)
                };
            }

            // Starfall animation for Safe Rest tile
            animateStarfall(callback) {
                console.log('üåü Starting starfall animation');
                
                // Create starburst glimmer on player at start
                this.createStarburstGlimmer();
                
                // Start falling stars animation for 2.5 seconds
                const starfallDuration = 2500;
                const stars = [];
                let starInterval;
                
                // Create stars at random intervals
                starInterval = setInterval(() => {
                    if (Math.random() < 0.7) { // 70% chance each interval to create a star
                        this.createFallingStar(stars);
                    }
                }, 150); // Create new stars every 150ms
                
                // Stop creating new stars and clean up after 2.5 seconds
                setTimeout(() => {
                    clearInterval(starInterval);
                    
                    // Create final starburst glimmer on player
                    this.createStarburstGlimmer();
                    
                    // Clean up remaining stars after animation
                    setTimeout(() => {
                        stars.forEach(star => {
                            if (star.element && star.element.parentNode) {
                                star.element.parentNode.removeChild(star.element);
                            }
                        });
                        
                        if (callback) callback();
                    }, 1000); // Wait 1 second after animation ends
                    
                }, starfallDuration);
            }

            createFallingStar(starsArray) {
                const star = document.createElement('div');
                star.innerHTML = '<img src="Assets/star.png" style="width: 140px; height: 140px; object-fit: contain;" onerror="this.outerHTML=\'‚≠ê\'">';
                star.style.position = 'fixed';
                star.style.fontSize = '140px';
                star.style.pointerEvents = 'none';
                star.style.zIndex = '1000';
                star.style.left = Math.random() * window.innerWidth + 'px';
                star.style.top = '-150px';
                star.style.transition = 'none';
                
                document.body.appendChild(star);
                
                const starData = {
                    element: star,
                    speed: 2 + Math.random() * 3, // Random speed between 2-5px per frame
                    x: parseInt(star.style.left),
                    y: -30
                };
                
                starsArray.push(starData);
                
                // Animate the star falling
                this.animateFallingStar(starData, starsArray);
            }

            animateFallingStar(starData, starsArray) {
                const animateFrame = () => {
                    starData.y += starData.speed;
                    starData.element.style.top = starData.y + 'px';
                    
                    // Remove star when it goes off screen
                    if (starData.y > window.innerHeight + 50) {
                        if (starData.element.parentNode) {
                            starData.element.parentNode.removeChild(starData.element);
                        }
                        // Remove from array
                        const index = starsArray.indexOf(starData);
                        if (index > -1) {
                            starsArray.splice(index, 1);
                        }
                        return;
                    }
                    
                    requestAnimationFrame(animateFrame);
                };
                
                requestAnimationFrame(animateFrame);
            }

            createStarburstGlimmer() {
                const player = document.getElementById('playerPiece');
                if (!player) return;
                
                // Create glimmer effect elements
                for (let i = 0; i < 5; i++) {
                    const glimmer = document.createElement('div');
                    glimmer.innerHTML = '<img src="Assets/star.png" style="width: 16px; height: 16px; object-fit: contain;" onerror="this.outerHTML=\'‚ú®\'">';
                    glimmer.style.position = 'absolute';
                    glimmer.style.fontSize = '16px';
                    glimmer.style.pointerEvents = 'none';
                    glimmer.style.zIndex = '999';
                    
                    // Position around the player
                    const angle = (i * 72) * (Math.PI / 180); // 5 stars, 72 degrees apart
                    const radius = 30;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    glimmer.style.left = x + 'px';
                    glimmer.style.top = y + 'px';
                    glimmer.style.opacity = '0';
                    glimmer.style.transition = 'all 0.6s ease-out';
                    
                    player.appendChild(glimmer);
                    
                    // Animate the glimmer
                    setTimeout(() => {
                        glimmer.style.opacity = '1';
                        glimmer.style.transform = 'scale(1.5) rotate(180deg)';
                    }, i * 100);
                    
                    // Remove the glimmer after animation
                    setTimeout(() => {
                        if (glimmer.parentNode) {
                            glimmer.parentNode.removeChild(glimmer);
                        }
                    }, 600 + (i * 100));
                }
            }

            // Fairy animation for Freebie tile
            animateFairy(callback) {
                console.log('üßö Starting fairy animation');
                
                const player = document.getElementById('playerPiece');
                if (!player) return;
                
                // Create fairy character using image asset
                const fairy = document.createElement('img');
                fairy.src = 'Assets/fairy2.png';
                fairy.style.position = 'fixed';
                fairy.style.width = '200px';
                fairy.style.height = '200px';
                fairy.style.pointerEvents = 'none';
                fairy.style.zIndex = '1000';
                fairy.style.transition = 'none';
                fairy.style.objectFit = 'contain';
                
                // Add error handling for missing image
                fairy.onerror = function() {
                    console.warn('Characters.png image not found, falling back to emoji');
                    const fallbackFairy = document.createElement('div');
                    fallbackFairy.innerHTML = 'üßö‚Äç‚ôÄÔ∏è';
                    fallbackFairy.style.cssText = fairy.style.cssText;
                    fallbackFairy.style.fontSize = '60px';
                    fallbackFairy.style.display = 'flex';
                    fallbackFairy.style.alignItems = 'center';
                    fallbackFairy.style.justifyContent = 'center';
                    fairy.parentNode.replaceChild(fallbackFairy, fairy);
                };
                
                document.body.appendChild(fairy);
                
                // Get player position for reference
                const playerRect = player.getBoundingClientRect();
                const playerCenterX = playerRect.left + playerRect.width / 2;
                const playerCenterY = playerRect.top + playerRect.height / 2;
                
                // Animation phases
                this.animateFairyEntry(fairy, playerCenterX, playerCenterY, () => {
                    this.animateFairySpin(fairy, playerCenterX, playerCenterY, () => {
                        this.animateFairyExit(fairy, () => {
                            // Clean up and callback immediately
                            if (fairy.parentNode) {
                                fairy.parentNode.removeChild(fairy);
                            }
                            
                            // Call callback immediately to show continue modal
                            if (callback) callback();
                        });
                    });
                });
            }

            animateFairyEntry(fairy, playerX, playerY, callback) {
                // Start position: left side of screen (account for larger fairy size)
                const startX = -220; // Further left to account for 200px width
                const startY = Math.random() * (window.innerHeight * 0.6) + (window.innerHeight * 0.2);
                
                fairy.style.left = startX + 'px';
                fairy.style.top = startY + 'px';
                
                // Animate along S-shaped path to player
                const duration = 2000; // 2 seconds to reach player
                const startTime = Date.now();
                
                const animateStep = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // S-curve path calculation (adjust for centered fairy image)
                    const currentX = startX + ((playerX - 50) - startX) * progress; // Center fairy horizontally
                    const amplitude = 100; // How "curvy" the S is
                    const frequency = 2; // Number of curves
                    const sOffset = Math.sin(progress * Math.PI * frequency) * amplitude * (1 - progress);
                    const currentY = startY + ((playerY - 50) - startY) * progress + sOffset; // Center fairy vertically
                    
                    fairy.style.left = currentX + 'px';
                    fairy.style.top = currentY + 'px';
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateStep);
                    } else {
                        if (callback) callback();
                    }
                };
                
                requestAnimationFrame(animateStep);
            }

            animateFairySpin(fairy, playerX, playerY, callback) {
                // Position fairy above player and spin (center the 200x200 image)
                const abovePlayerY = playerY - 220; // Higher to account for larger fairy
                fairy.style.left = (playerX - 100) + 'px'; // Center horizontally (subtract half width)
                fairy.style.top = abovePlayerY + 'px';
                
                // Spinning animation with rotation
                const spinDuration = 1500; // 1.5 seconds of spinning
                const startTime = Date.now();
                
                const spinStep = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / spinDuration;
                    const rotation = progress * 360; // Full rotation
                    
                    fairy.style.transform = `rotate(${rotation}deg)`;
                    
                    // At the moment of full spin (halfway through), trigger effects
                    if (elapsed >= spinDuration / 2 && !fairy.effectsTriggered) {
                        fairy.effectsTriggered = true;
                        this.triggerFairyEffects(playerX, playerY);
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(spinStep);
                    } else {
                        if (callback) callback();
                    }
                };
                
                requestAnimationFrame(spinStep);
            }

            animateFairyExit(fairy, callback) {
                // Exit to the right side of screen (account for larger fairy size)
                const endX = window.innerWidth + 220; // Further right to account for 200px width
                const startX = parseInt(fairy.style.left);
                const startY = parseInt(fairy.style.top);
                
                const duration = 1500; // 1.5 seconds to exit
                const startTime = Date.now();
                
                const animateStep = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    const currentX = startX + (endX - startX) * progress;
                    
                    fairy.style.left = currentX + 'px';
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateStep);
                    } else {
                        if (callback) callback();
                    }
                };
                
                requestAnimationFrame(animateStep);
            }

            triggerFairyEffects(playerX, playerY) {
                console.log('‚ú® Triggering fairy magical effects');
                
                // Create sparkly glimmer particles
                this.createSparklyGlimmer(playerX, playerY);
                
                // Fade out debuff icons and remove debuffs
                this.fadeOutDebuffs();
                
                // Don't add points here - wait for user to click continue
                console.log('üßö‚Äç‚ôÄÔ∏è Fairy effects triggered, waiting for continue button...');
            }

            createSparklyGlimmer(centerX, centerY) {
                // Create multiple sparkly particles that scatter outward
                for (let i = 0; i < 12; i++) {
                    const sparkle = document.createElement('div');
                    sparkle.innerHTML = '<img src="Assets/star.png" style="width: 48px; height: 48px; object-fit: contain;" onerror="this.outerHTML=\'‚ú®\'">';
                    sparkle.style.position = 'fixed';
                    sparkle.style.fontSize = '48px';
                    sparkle.style.pointerEvents = 'none';
                    sparkle.style.zIndex = '999';
                    sparkle.style.left = centerX + 'px';
                    sparkle.style.top = centerY + 'px';
                    sparkle.style.opacity = '1';
                    
                    document.body.appendChild(sparkle);
                    
                    // Random direction and distance for scattering
                    const angle = (i * 30) * (Math.PI / 180); // Evenly spaced around circle
                    const distance = 80 + Math.random() * 40; // Random scatter distance
                    const finalX = centerX + Math.cos(angle) * distance;
                    const finalY = centerY + Math.sin(angle) * distance;
                    
                    // Animate the sparkle
                    setTimeout(() => {
                        sparkle.style.transition = 'all 1s ease-out';
                        sparkle.style.left = finalX + 'px';
                        sparkle.style.top = finalY + 'px';
                        sparkle.style.opacity = '0';
                        sparkle.style.transform = 'scale(0.5) rotate(180deg)';
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (sparkle.parentNode) {
                                sparkle.parentNode.removeChild(sparkle);
                            }
                        }, 1000);
                    }, i * 50); // Staggered timing
                }
            }

            fadeOutDebuffs() {
                // Get reference to debuffs display and fade out visual debuffs
                const debuffsList = document.getElementById('debuffsList');
                if (debuffsList && window.gameInstance) {
                    const debuffItems = debuffsList.querySelectorAll('.debuff-item');
                    
                    debuffItems.forEach((item, index) => {
                        setTimeout(() => {
                            item.style.transition = 'opacity 0.5s ease-out';
                            item.style.opacity = '0';
                        }, index * 100);
                    });
                    
                    // Remove all debuffs from game state after visual fadeout
                    setTimeout(() => {
                        window.gameInstance.gameState.activeDebuffs = [];
                        window.gameInstance.updateDebuffsDisplay();
                    }, 600);
                }
            }
        }
        
        // ===== SCORE SYSTEM CLASS =====
        
        class ScoreSystem {
            constructor() {
                this.baseScore = 1000;
            }
            
            calculateFinalScore(gameState) {
                let score = this.baseScore;
                
                // Time bonus (faster = higher score)
                const timeMinutes = gameState.gameTime / 60000;
                const timeBonus = Math.max(0, 500 - (timeMinutes * 10));
                
                // Turn bonus (fewer turns = higher score)
                const turnPenalty = gameState.turn * 5;
                
                // Strength score factor
                const strengthBonus = gameState.strengthScore - 100;
                
                score = score + timeBonus - turnPenalty + strengthBonus;
                
                return Math.max(0, Math.round(score));
            }
            
            saveScore(score, personas, gameState) {
                const scores = JSON.parse(localStorage.getItem('boardbreaker_scores') || '[]');
                
                const newScore = {
                    score: score,
                    persona: personas,
                    turns: gameState.turn,
                    time: gameState.gameTime,
                    date: new Date().toISOString(),
                    strengthScore: gameState.strengthScore,
                    playerName: gameState.playerName || 'Anonymous',
                    id: Date.now() + Math.random() // Unique ID for each game
                };
                
                scores.push(newScore);
                
                // Keep all scores (no limit) for comprehensive history
                // Sort by score (highest first) for leaderboard display
                scores.sort((a, b) => b.score - a.score);
                
                localStorage.setItem('boardbreaker_scores', JSON.stringify(scores));
                console.log(`üíæ Saved score: ${score} for ${personas.personality}/${personas.playstyle}/${personas.movement}`);
            }
            
            getAllScores() {
                return JSON.parse(localStorage.getItem('boardbreaker_scores') || '[]');
            }
            
            getTopScores(limit = 20) {
                const allScores = this.getAllScores();
                return allScores.slice(0, limit);
            }
            
            formatTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            getPersonaDisplayName(persona) {
                const personality = persona.personality || 'Unknown';
                const playstyle = persona.playstyle || 'Unknown';
                const movement = persona.movement || 'Unknown';
                
                return {
                    full: `${personality}/${playstyle}/${movement}`,
                    personality: personality.charAt(0).toUpperCase() + personality.slice(1),
                    playstyle: playstyle.charAt(0).toUpperCase() + playstyle.slice(1),
                    movement: movement.charAt(0).toUpperCase() + movement.slice(1)
                };
            }
        }
        
        // ===== UTILITY FUNCTIONS =====
        
        function showModal(modalId) {
            document.getElementById(modalId).classList.add('active');
        }
        
        function hideModal(modalId) {
            closeModal(modalId);
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            
            // Execute pending callback if it exists (for ladders/chutes/movement)
            if (modalId === 'squareModal' && window.game && window.game.pendingModalCallback) {
                console.log(`üîÑ Closing squareModal - executing pending callback`);
                
                // Check for prevention checkbox (View Ahead modal)
                const preventCheckbox = document.getElementById('preventBadEventsCheckbox');
                if (preventCheckbox && preventCheckbox.checked && window.game.currentPreventionTiles) {
                    console.log(`üõ°Ô∏è Applying prevention effect for View Ahead tiles`);
                    window.game.activatePreventionEffect(window.game.currentPreventionTiles);
                    window.game.currentPreventionTiles = null; // Clear after use
                }
                
                const callback = window.game.pendingModalCallback;
                window.game.pendingModalCallback = null;
                console.log(`‚ö° About to execute callback:`, callback);
                callback();
                console.log(`‚úÖ Callback execution completed`);
            } else {
                console.log(`üîÑ Closing ${modalId} - no callback to execute`);
            }
        }
        
        function showGameRules() {
            alert('Boardbreaker Rules\n\nObjective: Reach square 50 without triggering your persona\'s death condition.\n\nPersona Deaths:\n- Tactician: Trapped 3 times\n- Daredevil: 3 traps in a row\n- Lucky: 3 luck failures\n- Persistent: 5 total failures\n- Sprinter: Focus on speed and efficiency\n- Jumper: 3 failed jumps\n\nGood luck!');
        }
        
        function resetGame() {
            closeModal('gameOverModal');
            document.getElementById('gameInterface').style.display = 'none';
            document.getElementById('welcomeScreen').style.display = 'block';
        }
        
        function editCharacter() {
            closeModal('gameplayPreviewModal');
            // Stay on customization screen - user can make changes
        }
        
        function continueToGame() {
            closeModal('gameplayPreviewModal');
            showLoadingScreen();
        }
        
        function showScoreboard() {
            const scoreSystem = window.game ? window.game.scoreSystem : new ScoreSystem();
            const scores = scoreSystem.getAllScores();
            
            let scoreboardHTML = '';
            
            if (scores.length === 0) {
                scoreboardHTML = `
                    <div style="text-align: center; padding: 3rem; color: #6b7280;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">üéØ</div>
                        <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">No scores yet!</div>
                        <div>Complete your first game to see your score here.</div>
                    </div>
                `;
            } else {
                scoreboardHTML = `
                    <div class="scoreboard-stats" style="display: flex; justify-content: space-around; margin-bottom: 2rem; padding: 1rem; background: rgba(59, 130, 246, 0.1); border-radius: 10px;">
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: var(--primary-color);">${scores.length}</div>
                            <div style="font-size: 0.9rem; color: #6b7280;">Games Played</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: var(--success-color);">${scores[0].score}</div>
                            <div style="font-size: 0.9rem; color: #6b7280;">Best Score</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: var(--accent-color);">${scoreSystem.formatTime(Math.min(...scores.map(s => s.time)))}</div>
                            <div style="font-size: 0.9rem; color: #6b7280;">Best Time</div>
                        </div>
                    </div>
                    
                    <div class="scoreboard-table" style="max-height: 400px; overflow-y: auto;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                            <thead>
                                <tr style="background: rgba(0,0,0,0.1); position: sticky; top: 0;">
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e5e7eb;">#</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e5e7eb;">Player</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e5e7eb;">Score</th>
                                    <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #e5e7eb;">Character</th>
                                    <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #e5e7eb;">Time</th>
                                    <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #e5e7eb;">Turns</th>
                                    <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #e5e7eb;">Date</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                scores.slice(0, 50).forEach((score, index) => {
                    const persona = scoreSystem.getPersonaDisplayName(score.persona);
                    const date = new Date(score.date).toLocaleDateString();
                    const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
                    const rankEmoji = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '';
                    
                    scoreboardHTML += `
                        <tr style="border-bottom: 1px solid #f3f4f6; ${index % 2 === 0 ? 'background: rgba(0,0,0,0.02);' : ''}" class="score-row ${rankClass}">
                            <td style="padding: 0.75rem; font-weight: bold;">${rankEmoji} ${index + 1}</td>
                            <td style="padding: 0.75rem; font-weight: bold; color: var(--primary-color); max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${score.playerName || 'Anonymous'}">${score.playerName || 'Anonymous'}</td>
                            <td style="padding: 0.75rem; font-weight: bold; color: var(--success-color);">${score.score.toLocaleString()}</td>
                            <td style="padding: 0.75rem;">
                                <div style="font-weight: 600; font-size: 0.9rem;">${persona.personality}</div>
                                <div style="font-size: 0.75rem; color: #6b7280;">${persona.playstyle} ‚Ä¢ ${persona.movement}</div>
                            </td>
                            <td style="padding: 0.75rem; text-align: center; font-family: monospace; font-size: 0.9rem;">${scoreSystem.formatTime(score.time)}</td>
                            <td style="padding: 0.75rem; text-align: center; font-size: 0.9rem;">${score.turns}</td>
                            <td style="padding: 0.75rem; text-align: center; font-size: 0.75rem; color: #6b7280;">${date}</td>
                        </tr>
                    `;
                });
                
                scoreboardHTML += `
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            document.getElementById('scoreboardContent').innerHTML = scoreboardHTML;
            showModal('scoreboardModal');
        }
        
        function clearScoreboard() {
            if (confirm('Are you sure you want to clear all score history? This cannot be undone.')) {
                localStorage.removeItem('boardbreaker_scores');
                showScoreboard(); // Refresh the display
            }
        }

        function showLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.style.display = 'flex';
            
            // Trigger animation
            setTimeout(() => {
                loadingScreen.classList.add('active');
            }, 50);

            // Simulate loading time then start game
            setTimeout(() => {
                hideLoadingScreen();
            }, 3000); // 3 seconds loading
        }

        function hideLoadingScreen() {
            console.log('üîÑ hideLoadingScreen() called');
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.classList.remove('active');
            
            setTimeout(() => {
                loadingScreen.style.display = 'none';
                console.log('üöÄ About to call game.startGame()');
                console.log('Game object:', game);
                console.log('Game personas before start:', game.personas);
                
                try {
                    game.startGame(); // Actually start the game after loading
                    console.log('‚úÖ game.startGame() completed successfully');
                } catch (error) {
                    console.error('‚ùå game.startGame() failed:', error);
                    alert('Error starting game: ' + error.message);
                    // Reset to welcome screen on error
                    document.getElementById('gameInterface').style.display = 'none';
                    document.getElementById('welcomeScreen').style.display = 'block';
                }
            }, 500); // Wait for fade out
        }
        
        function quitGame() {
            resetGame();
        }
        
        // ===== INITIALIZE GAME =====
        
        let game;
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Boardbreaker Loading...');
            game = new BoardbreakerGame();
            window.gameInstance = game; // Global reference for animations
            console.log('‚úÖ Boardbreaker Ready!');
        });
    </script>
</body>
</html>

